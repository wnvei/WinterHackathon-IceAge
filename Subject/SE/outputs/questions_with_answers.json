{
  "questions": [
    {
      "id": 1,
      "module": "MODULE-2",
      "topic": "Requirements engineering Process, Requirement elicitation, Requirement specification, Requirement Validation and management Applications",
      "question": "Explain the difference between Functional and Non-Functional requirements.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "Jan_2025(2022Scheme).pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Functional Requirements:\n1.  Define WHAT the system SHOULD DO, focusing on specific functions, inputs, and outputs.\n2.  Written in clear, natural language for users, and detailed for developers.\n3.  Ambiguity can lead to misunderstandings, delays, and increased costs.\n4.  Describe WHAT the system should do, not HOW it does it.\n\nNon-Functional Requirements:\n1.  Focus on system CHARACTERISTICS (e.g., reliability, performance, security) rather than specific services.\n2.  May affect the overall system architecture.\n3.  Sources of non-functional requirements include:\n    *   Product requirements: Performance, reliability, security, usability, efficiency, space.\n    *   Organizational requirements: Policies, development standards, environment, operational, development, accounting.\n    *   External requirements: Regulatory, legislative, ethical, safety/security.\n4.  Qualities and constraints that define HOW a system performs rather than what it does.\n\nIn simpler terms, functional requirements specify WHAT a system should do, while non-functional requirements specify HOW well it should do it. Functional requirements define features, while non-functional requirements define the quality attributes of those features."
    },
    {
      "id": 2,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "Explain extreme programming (XP).",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "Mar_Apr_2024(2021Scheme) (4) (2).pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Extreme Programming (XP) is an Agile software development methodology introduced by Kent Beck in the 1990s. It focuses on improving software quality and responsiveness to changing requirements through frequent releases and strong collaboration between developers and customers.\n\nKey Practices of XP:\n\n1.  **Frequent Releases:** Delivering small, functional increments of software frequently.\n2.  **Pair Programming:** Two developers work together at one workstation to improve code quality.\n3.  **Test-First Development (TDD):** Tests are written before the code to ensure correctness and maintainability.\n4.  **User Stories:** Requirements are captured in short, simple descriptions of desired functionality.\n5.  **Continuous Integration:** Code is integrated and tested daily to detect issues early.\n6.  **Continuous Customer Involvement:** Constant feedback from the customer is incorporated throughout the development process.\n7.  **Shared Code Ownership:** The code is collectively owned by the team.\n8.  **Regular Refactoring:** Constantly improving code to keep it clean and flexible by removing duplicate code, renaming methods, and reorganizing classes.\n9.  **Simple Designs:** Keeping designs simple and adaptable.\n\nThe goal of XP is to produce high-quality software quickly while accommodating changing customer requirements through constant feedback and collaboration.\n\nXP release cycle steps:\n\n1.  **Select User Stories:** User stories are chosen based on customer priorities and business value.\n2.  **Break Down Stories to Tasks:** Each user story is divided into smaller development tasks.\n3.  **Plan Release:** A release plan is created, outlining which stories will be delivered and when.\n4.  **Develop / Integrate / Test Software:** Development teams write code, integrate components, and perform continuous testing, utilizing pair programming and TDD.\n5.  **Release Software:** Once tested, the increment is delivered to the customer for immediate use.\n6.  **Evaluate System:** Feedback is collected from users and stakeholders to assess performance, usability, and feature improvements for the next iteration."
    },
    {
      "id": 3,
      "module": "MODULE-3",
      "topic": "Interaction models",
      "question": "Describe interaction models with an example.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "Mar_Apr_2024(2021Scheme) (4) (2).pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Interaction models are important for understanding user requirements and potential communication problems between systems. They also help in assessing whether a proposed system structure will meet the required system performance and dependability.\n\nThese models can be represented using:\n\n1.  **Use Case Diagrams:**  Each use case represents a discrete task involving external interaction with a system. Actors in a use case may be people or other systems.  Use case diagrams provide an overview of the use case, and more detailed textual descriptions can be provided in a tabular form.\n\n    *   For example, the `Transfer-data` use case involves a medical receptionist initiating a transaction, with data transferred to the patient record system. (Refer to the notes for a diagram illustrating the \"Transfer data\" use case. Also Refer to notes for Tabular description of the ‘Transfer data’ use-case and Use cases in the MHC-PMS involving the role ‘Medical Receptionist’)\n2.  **Sequence Diagrams:** Part of UML, these model interactions between actors and objects within a system.  A sequence diagram shows the sequence of interactions that take place during a particular use case or use case instance. Objects and actors are listed along the top, with interactions indicated by annotated arrows.\n\n    *   For instance, in a 'View patient information' sequence diagram, the medical receptionist triggers the `ViewInfo` method in a PatientInfo object, supplying the patient's identifier. (Refer to the notes for diagrams illustrating the sequence diagram for 'View patient information' and 'Transfer Data')"
    },
    {
      "id": 4,
      "module": "MODULE-3",
      "topic": "System models",
      "question": "List and explain any four system perspectives in system modeling.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The four system perspectives in system modeling are:\n\n1.  **External Perspective**: This involves modeling the context or environment of the system. It defines the system boundaries and illustrates the operational context, showing what lies outside the system. Architectural models are a part of this perspective, showing the system and its relationships with other systems.\n\n2.  **Interaction Perspective**: This perspective focuses on modeling the interactions between a system and its environment, or between the components within a system. It highlights communication problems that may arise. Use case diagrams and sequence diagrams are used for interaction modeling.\n\n3.  **Structural Perspective**: Here, the organization of a system or the structure of the data processed by the system is modeled. These models can be static, showing the structure of the system design, or dynamic, showing the organization of the system during execution. Class diagrams are commonly used to represent structural aspects.\n\n4.  **Behavioral Perspective**: This perspective models the dynamic behavior of the system and how it responds to events. It is based on the assumption that a system has a finite number of states and that events (stimuli) may cause a transition from one state to another. State diagrams are used to represent state machine models, showing system states as nodes and events as arcs between these nodes."
    },
    {
      "id": 5,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "Demonstrate scenario testing with an example.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 2,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "MEDIUM",
      "notes_validation": "CONFIRMED",
      "answer": "Scenario Testing is a software testing technique that uses scenarios (speculative stories) to help testers work through complicated problems or test systems. The ideal scenario test is a reliable, complicated, convincing, or motivating story where the outcome is easy to assess. It ensures the end-to-end functioning of the software and that all process flows work correctly.\n\nIn scenario testing, testers assume the role of end-users and identify real-world scenarios or use cases that end-users might perform on the software. Testers collaborate with clients, stakeholders, and developers to create test scenarios. A test scenario is a story describing how an end-user would use the software.\n\n**Example:**\n\n**Application:** ATM Machine\n\n**Scenario:** \"Withdraw cash successfully\"\n\n**Steps:**\n\n1.  User inserts ATM card. → Expected: Machine asks for PIN.\n2.  User enters correct PIN. → Expected: Access granted.\n3.  User selects \"Withdraw Cash\" option. → Expected: Withdrawal menu appears.\n4.  User enters amount (e.g., ₹500). → Expected: Machine checks balance.\n5.  Balance is sufficient. → Expected: Cash is dispensed, receipt printed, and balance updated."
    },
    {
      "id": 6,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "Explain user testing and list three types of user testing.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "User testing is a software validation technique that checks if the final software meets the customer's real needs (product quality). It involves activities like testing (unit, integration, system, acceptance), prototyping, and user feedback sessions.\n\nThree types of user testing mentioned in the notes are:\n\n1.  Component Testing: Each part is tested alone by developers using tools.\n2.  System Testing: All parts are combined and tested for interaction issues and requirements.\n3.  Customer Testing: Real users test the system with real data to find missing or unclear requirements."
    },
    {
      "id": 7,
      "module": "MODULE-3",
      "topic": "UML diagram types",
      "question": "Explain the different types of UML Diagrams.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The Unified Modeling Language (UML) is a graphical notation used to represent a system from different perspectives. The different types of UML diagrams are:\n\n1.  **Activity Diagrams:** Activity diagrams show the activities involved in a process or in data processing.\n\n2.  **Use Case Diagrams:** Use case diagrams show the interactions between a system and its environment, depicting discrete tasks involving external interaction with the system. Actors in a use case may be people or other systems. The use case is diagrammatically represented to provide an overview and in a more detailed textual form.\n\n3.  **Sequence Diagrams:** Sequence diagrams model the interactions between actors and the objects within a system, showing the sequence of interactions that take place during a particular use case or use case instance. Objects and actors are listed along the top of the diagram, with a dotted line drawn vertically from these. Interactions between objects are indicated by annotated arrows.\n\n4.  **Class Diagrams:** Class diagrams show the object classes in the system and the associations between these classes. An object class is a general definition of one kind of system object, and an association is a link between classes that indicates a relationship. Generalization can be applied to see if there is scope for generalization. In a generalization, attributes and operations from higher-level classes are also associated with lower-level classes. Lower-level classes inherit attributes and operations from their superclasses and add more specific attributes and operations. An aggregation model shows how classes that are collections are composed of other classes.\n\n5.  **State Diagrams:** State diagrams show how the system reacts to internal and external events. They model the behavior of the system in response to these events, showing the system's responses to stimuli. They are often used for modeling real-time systems, displaying system states as nodes and events as arcs between these nodes. When an event occurs, the system moves from one state to another."
    },
    {
      "id": 8,
      "module": "MODULE-3",
      "topic": "Event driven modeling, Model driven engineering Applications",
      "question": "Illustrate what is event driven modeling.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Event-driven modeling shows how a system responds to external and internal events. It operates on the principle that a system has a limited number of states, and events (stimuli) can trigger a transition from one state to another. State machine models are used to model this behavior, representing system states as nodes and events as arcs between these nodes. When an event occurs, the system moves from one state to another.\n\nRefer to the notes for a state model diagram to visualize system states as nodes and events as arcs between nodes, illustrating state transitions in response to events."
    },
    {
      "id": 9,
      "module": "MODULE-3",
      "topic": "sequence diagram",
      "question": "Explain sequence diagrams with the help of an example.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Sequence diagrams are part of the UML (Unified Modeling Language) and are used to model the interactions between actors and the objects within a system. They show the sequence of interactions that take place during a particular use case or use case instance.\n\nKey aspects of sequence diagrams:\n\n1.  **Actors and Objects:** The objects and actors involved are listed along the top of the diagram, with a dotted line drawn vertically from these.\n2.  **Interactions:** Interactions between objects are indicated by annotated arrows.\n\n**Example: View Patient Information**\n\nConsider a sequence diagram for viewing patient information within a medical system (Mentcare System):\n\n1.  The medical receptionist triggers the `ViewInfo` method in an instance `P` of the `PatientInfo` object class, supplying the patient's identifier, `PID`.\n2.  `P` is a user interface object, which is displayed as a form showing patient information.\n3.  The instance `P` calls the database to return the information required, supplying the receptionist's identifier to allow security checking (at this stage, the source of this `UID` is not specified).\n4.  The database checks with an authorization system that the user is authorized for this action.\n5.  If authorized, the patient information is returned, and a form on the user's screen is populated. If authorization fails, an error message is returned.\n\n**Example: Transfer Data**\n\nConsider a sequence diagram for transferring data within a medical system (Mentcare System):\n\n1. The receptionist logs on to the PRS (Patient Record System).\n2. There are two options available: direct transfer of updated patient information to the PRS and transfer of summary health data from the MHC-PMS (Mental Health Care Patient Management System) to the PRS.\n3. In each case, the receptionist's permissions are checked using the authorization system.\n4. Personal information may be transferred directly from the user interface object to the Patient Record System (PRS). Alternatively, a summary record may be created from the database and that record is then transferred.\n5. On completion of the transfer, the PRS issues a status message, and the user logs off."
    },
    {
      "id": 10,
      "module": "MODULE-3",
      "topic": "Event driven modeling, Model driven engineering Applications",
      "question": "What is event-driven modeling? Show a simple diagram of a state model for microwave oven operation.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Event-driven modeling shows how a system responds to external and internal events. It operates on the principle that a system possesses a finite number of states, and events trigger transitions between these states. It is particularly relevant for real-time systems where data processing is minimal, such as a landline phone system reacting to a 'receiver off hook' event by producing a dial tone. \n\nThe notes do not provide a state model diagram for a microwave oven. However, I can describe what it should show. Refer to notes for diagram. The state model of a microwave oven should include states such as:\n\n1.  **Idle**: The initial state where the microwave is waiting for user input.\n2.  **Setting Time**: The user is inputting the cooking time.\n3.  **Setting Power Level**: The user is setting the power level.\n4.  **Cooking**: The microwave is actively cooking.\n5.  **Paused**: The cooking process is temporarily stopped.\n6.  **Finished**: The cooking time has elapsed, and the food is ready.\n\nTransitions between these states would be triggered by events like:\n\n*   **Start**: Initiates the cooking process.\n*   **Pause**: Temporarily halts the cooking.\n*   **Resume**: Continues cooking from the paused state.\n*   **Timer Expires**: The set cooking time has finished.\n*   **Open Door**: Interrupts the cooking process.\n*   **Close Door**: Allows cooking to resume (or start).\n*   **Set Time**: Enters the state for setting the cooking duration.\n*   **Set Power Level**: Enters the state for adjusting the power level.\n\nEach state transition would involve actions such as:\n\n*   **Displaying Information**: Updating the display to show the current state, time remaining, or power level.\n*   **Controlling Microwave Components**: Activating or deactivating the magnetron, turntable, and lights.\n*   **Sounding Alarms**: Alerting the user when cooking is complete or if an error occurs.\n\nThe state diagram visually represents the microwave's behavior in response to these events, with nodes representing states and arcs representing event-triggered transitions."
    },
    {
      "id": 11,
      "module": "MODULE-3",
      "topic": "class diagram, generalization, Aggregation",
      "question": "Illustrate class diagrams with the help of an example diagram and evaluate its effectiveness in system modeling.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Error during generation."
    },
    {
      "id": 12,
      "module": "MODULE-3",
      "topic": "Behavioral Models -Data driven modeling",
      "question": "Explain behavioural models and draw a simple activity model of the insulin pump’s operation.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Behavioural models are models of the dynamic behavior of a system as it is executing. They show what happens or what is supposed to happen when a system responds to a stimulus from its environment. The stimuli can be:\n\n1.  Data: Some data arrives that has to be processed by the system.\n2.  Events: Some event happens that triggers system processing. Events may have associated data, although this is not always the case.\n\nTwo types of behavioral models are:\n\n*   Data-driven modeling: Many business systems are data-processing systems that are primarily driven by data. They are controlled by the data input to the system, with relatively little external event processing. Data-driven models show the sequence of actions involved in processing input data and generating an associated output. They are particularly useful during the analysis of requirements as they can be used to show end-to-end processing in a system.\n*   Event-driven modeling: Real-time systems are often event-driven, with minimal data processing. Event-driven modeling shows how a system responds to external and internal events. It is based on the assumption that a system has a finite number of states and that events (stimuli) may cause a transition from one state to another.\n\n**Activity model of the insulin pump’s operation:** Refer notes for diagram. The diagram depicts a sequence of activities. The first activity is to measure blood sugar. The next is to calculate insulin required. Following that is to deliver insulin. After that, there is a check to see if more insulin is required. If more insulin is not required, the process ends. If more insulin is required, the process returns to the measure blood sugar activity."
    },
    {
      "id": 13,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "Compare software inspection and software testing, and model the software testing process with a diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Software Inspection vs. Software Testing:\n\n1.  **Purpose:**\n *   Software Inspection: Primarily focused on *verification*, ensuring the software is built correctly according to specifications and design. It emphasizes process quality.\n *   Software Testing: Primarily focused on *validation*, ensuring that the final software meets the customer’s real needs. It emphasizes product quality.\n\n2.  **Methods:**\n *   Software Inspection: Includes reviews (code reviews, design reviews), walkthroughs, inspections, and static analysis (checking code without running it).\n *   Software Testing: Includes dynamic testing methods like unit testing, integration testing, system testing, and acceptance testing, which involve executing the code.\n\n3.  **Focus:**\n *   Software Inspection: Focuses on detecting defects through examination and analysis before execution. It checks if the code adheres to coding standards, design principles, and requirements.\n *   Software Testing: Focuses on detecting defects by executing the software with test data and comparing the actual output with the expected output.\n\n4.  **Timing:**\n *   Software Inspection: Typically performed early in the software development lifecycle (SDLC), such as after code is written but before testing.\n *   Software Testing: Performed at various stages of the SDLC, including unit testing, integration testing, system testing, and acceptance testing.\n\n5.  **Goals:**\n *   Software Inspection: Aims to improve code quality, reduce defects, and ensure compliance with standards and requirements.\n *   Software Testing: Aims to identify errors, validate functionality, and ensure the software meets user needs.\n\n6.  **Examples:**\n *   Software Inspection: Verifying if the code enforces password rules as defined in the specification (e.g., \"Password must be at least 8 characters\").\n *   Software Testing: Ensuring the login process satisfies security needs and customer requirements for secure login.\n\n7.  **Perspective:**\n *   Software Inspection: Checks if the design matches requirements and if the requirements are clear, complete, and consistent.\n *   Software Testing: Validates that the delivered product meets user needs in a real environment.\n\nSoftware Testing Process Model Diagram:\n\nRefer to notes for diagram (V-model of software development).\n\n*The V-model* illustrates the software development and testing process step by step, showing how each development phase has a corresponding testing phase.\n\n**Left Side of the V: Development Phases**\n\n1.  **Requirements Specification:** Understanding customer needs.\n2.  **System Specification:** Translating customer needs into detailed system-level requirements.\n3.  **System Design:** Designing the architecture of the system and how components will interact.\n4.  **Component Design:** Designing individual modules or components that will be coded.\n\nEach phase leads to a corresponding test plan:\n\n*   Customer Test Plan\n*   System Integration Test Plan\n*   Sub-system Integration Test Plan\n*   Component Test Plan\n\n**Right Side of the V: Testing Phases**\n\n*This side mirrors the development stages and focuses on testing and validation.*\n\n1.  **Component Code and Test:** Developers write code and test individual components.\n2.  **Sub-system Integration Test:** Tests how components work together within subsystems.\n3.  **System Integration Test:** Ensures all subsystems integrate correctly.\n4.  **Customer Test:** Validates the system against the original requirements.\n5.  **Service:** Ongoing support and maintenance after deployment.\n\nThe V-shape shows how each development activity has a corresponding test activity, reinforcing that testing is planned from the beginning."
    },
    {
      "id": 14,
      "module": "MODULE-4",
      "topic": "Design patterns",
      "question": "Explain the Observer design pattern in detail.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The Observer design pattern separates the display of an object's state from the object itself. It is used when multiple displays of state are needed.\n\nHere's a detailed breakdown:\n\n1.  **Name:** Observer.\n2.  **Description:** This pattern isolates the representation of object state from the object itself, enabling independent modifications and reuse of displays.\n3.  **Problem Description:** The Observer pattern addresses the scenario when multiple displays or views of the same data or object state are required, and these views need to be updated automatically whenever the object's state changes. Without this pattern, the object would need to manage all its dependent views, leading to tight coupling and reduced flexibility.\n4.  **Solution Description:** Refer notes for UML description. The core idea involves defining a Subject (the object whose state is being observed) and Observers (the objects that display the state). The Subject maintains a list of Observers and notifies them whenever its state changes. Each Observer then updates its display to reflect the new state. This is generally done through:\n * Subject Interface: An interface or abstract class that defines methods for attaching, detaching, and notifying observers.\n * Concrete Subject: The class whose state is being observed. It implements the Subject interface, maintains the state, and notifies observers of state changes.\n * Observer Interface: An interface or abstract class that defines the update method, which is called by the Subject when its state changes.\n * Concrete Observers: Classes that implement the Observer interface. Each observer maintains a reference to the Concrete Subject and updates its display when notified.\n5.  **Consequences:** A key consequence is that optimizations to enhance display performance are impractical when employing the Observer pattern. This arises because each observer independently handles its update logic, precluding coordinated optimization strategies across multiple displays. The pattern promotes flexibility by decoupling the subject from its observers, allowing observers to be added or removed without modifying the subject. However, this decoupling can lead to runtime overhead due to the notifications and updates, potentially impacting performance, especially when many observers are involved. Additionally, it ensures that changes to the Subject's state are immediately reflected in all associated Observers, maintaining consistency across multiple displays."
    },
    {
      "id": 15,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "What is test-driven development (TDD)? Identify the activities and benefits of TDD.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Test-driven development (TDD) is an agile development technique where tests are written before the code to ensure correctness and maintainability. Here's a breakdown of its activities and benefits:\n\n**Activities of TDD:**\n\n1.  **Write a Test First:** Before writing any code, a test is written that defines a specific functionality or behavior. This test will initially fail because the code it's testing doesn't exist yet.\n2.  **Run the Test:** Execute the test to confirm that it fails as expected. This step ensures that the test is actually testing the intended functionality and that it's not a false positive.\n3.  **Write the Code:** Write the minimum amount of code necessary to pass the test. The focus is solely on making the test pass, not on creating perfect or complete code.\n4.  **Run the Test Again:** Execute the test again. If the code is correct, the test will pass. If it fails, the code needs to be adjusted until the test passes.\n5.  **Refactor:** Once the test passes, refactor the code to improve its structure, readability, and maintainability. This may involve removing duplication, simplifying logic, or improving naming. It is important to re-run the tests after refactoring to ensure no new issues are introduced.\n6.  **Repeat:** The process is repeated for each new functionality or behavior that needs to be implemented. Each new feature begins with writing a test, then writing code to pass the test, and finally refactoring.\n\n**Benefits of TDD:**\n\n1.  **Early Problem Detection:** Writing tests before code helps catch problems early in the development cycle.\n2.  **Reduced Misunderstandings:** Writing tests helps clarify requirements and ensures that developers have a clear understanding of what the code should do.\n3.  **Avoids Test-Lag:** By writing tests upfront, TDD avoids the problem of \"test-lag,\" where testing is delayed until late in the development cycle.\n4.  **Fast Feedback:** Tests run quickly and often, providing developers with immediate feedback on the correctness of their code.\n5.  **High-Quality Code:** TDD promotes clean code, good design, and maintainable software. It ensures technical excellence.\n6.  **Clear Requirements:** TDD uses customer involvement in creating acceptance tests.\n\nWhile the notes mention some challenges such as incomplete test coverage and difficulty writing certain tests (e.g., UI logic), the benefits generally outweigh these challenges when TDD is implemented correctly."
    },
    {
      "id": 16,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "What is release testing, and how does it differ from system testing?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Release testing is the process of testing a particular release of a system, that is intended for use outside of the development team. The main goal is to check that the system meets its requirements and is good enough for external use. It involves testing the software in its target environment. \n\nSystem testing, on the other hand, involves integrating components to create a version of the system and then testing the integrated system. The focus in system testing is testing the interactions between components. It checks that components are compatible, interact correctly and transfer the right data at the right time across their interfaces. System testing tests the emergent behavior of a system."
    },
    {
      "id": 17,
      "module": "MODULE-3",
      "topic": "class diagram, generalization, Aggregation",
      "question": "Explain aggregation and generalization in system modeling.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Aggregation and generalization are both modeling techniques used to manage complexity by grouping similar entities.\n\n1.  **Generalization:** This is an everyday technique used to manage complexity. Rather than learning detailed characteristics of every entity, entities are placed into general classes (e.g., animals, cars, houses) and learn the characteristics of these classes. It allows inferring that different members of these classes have some common characteristics (e.g., squirrels and rats are rodents). In modeling systems, it is often useful to examine the classes in a system to see if there is scope for generalization. If changes are proposed, then you do not have to look at all classes in the system to see if they are affected by the change. In object-oriented languages such as Java, generalization is implemented using class inheritance mechanisms. In a generalization, the attributes and operations associated with higher-level classes are also associated with the lower-level classes. The lower-level classes or subclasses inherit the attributes and operations from their superclasses. These lower-level classes then add more specific attributes and operations. Refer notes for 'A generalization hierarchy' diagram (showing class inheritance) and 'A generalization hierarchy with added detail' diagram.\n\n2.  **Aggregation:** An aggregation model shows how classes that are collections are composed of other classes. Aggregation models are similar to the part-of relationship in semantic data models."
    },
    {
      "id": 18,
      "module": "MODULE-3",
      "topic": "Behavioral Models -Data driven modeling",
      "question": "Compare state diagrams and activity diagram types.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "State diagrams and activity diagrams are both UML diagram types used in system modeling to represent different perspectives of a system's behavior. Here's a comparison of the two:\n\n1.  **Purpose**: State diagrams model the behavior of a *single object* in response to events and state transitions. Activity diagrams model the *activities involved in a process or data processing*, showing the flow of control from one activity to another.\n2.  **Focus**: State diagrams focus on the different *states* an object can be in and the *events* that cause transitions between these states. Activity diagrams focus on the *sequence of actions or activities* performed within a process, including decision points and parallel execution paths.\n3.  **Elements**: State diagrams use *states* (nodes representing a condition during which an object satisfies some condition, performs some activity, or waits for an event) and *transitions* (arcs representing a change from one state to another, triggered by an event). Activity diagrams use *activity states* (representing the performance of an action), *actions* (simple, non-divisible steps within an activity), *control flows* (showing the sequence of activities), *decision nodes* (representing conditional branches), and *fork/join nodes* (representing parallel execution).\n4.  **Usage**: State diagrams are often used for modeling *real-time systems* or the behavior of complex objects with distinct states and event-driven behavior. Activity diagrams are used for modeling *business processes*, *workflows*, or the steps involved in a complex computation or algorithm.\n5.  **Scope**: State diagrams typically model the behavior of a *single object or component* within a system. Activity diagrams can model a *broader scope*, representing the flow of activities across multiple objects or components.\n6.  **Abstraction Level**: State diagrams tend to be more *abstract*, focusing on the essential states and transitions of an object. Activity diagrams can be more *concrete*, showing the detailed steps and decision points within a process.\n7.  **Notation**: State diagrams represent system states as *nodes* and events as *arcs* between these nodes. Activity diagrams show activities, control flows, decision nodes, and fork/join nodes, providing a visual representation of the process flow.\n8. **Example Scenarios**:  A *state diagram* can model the operation state of the insulin pump. An *activity diagram* can model the overall operation of the insulin pump and the process of taking an order and sending it to a supplier.\n\nIn summary, state diagrams model how an object reacts to events, while activity diagrams show the activities in a process. Both types of diagrams are helpful in understanding the different aspects of dynamic system behavior."
    },
    {
      "id": 19,
      "module": "MODULE-3",
      "topic": "System models",
      "question": "What is system modeling? Explain the role of use case diagrams.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "System modeling is the process of developing abstract models of a system, with each model presenting a different view or perspective of that system. System modeling commonly involves representing a system using a graphical notation, often based on the Unified Modeling Language (UML).\n\nUse case diagrams play a significant role in system modeling by showing the interactions between a system and its environment. They are used for interaction modeling to identify user requirements and represent discrete tasks involving external interaction with a system. Actors in a use case may be people or other systems. Use case diagrams include actors (users or other systems), use cases (interactions), and lines connecting actors to use cases, with arrows indicating who initiates the interaction. Each use case can include multiple scenarios, covering normal and exception flows.\n\nRole of Use Case Diagrams:\n\n1.  Requirements Elicitation: Use case diagrams were originally developed to support requirements elicitation.\n2.  Interaction Modeling: They model user interaction, aiding in the identification of user requirements.\n3.  System Overview: Use case diagrams provide an overview of the use case, represented diagrammatically, along with a more detailed textual form.\n4.  Task Representation: Each use case represents a discrete task involving external interaction with a system.\n5.  Actor Identification: Actors in a use case may be people or other systems.\n6.  Scenario Inclusion: Each use case can include multiple scenarios, covering normal and exception flows.\n7.  Stakeholder Communication: Facilitates discussion about an existing or proposed system.\n8.  System Design: Used to design the system."
    },
    {
      "id": 20,
      "module": "MODULE-4",
      "topic": "Software Design",
      "question": "What is a design model, and what are the two types of design models?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "A design model is a creative activity in which you identify software components and their relationships, based on a customer's requirements. The two types of design models are:\n\n1.  Static models: These models describe the static structure of the system in terms of object classes and relationships.\n2.  Dynamic models: These models describe the dynamic interactions between objects."
    },
    {
      "id": 21,
      "module": "MODULE-3",
      "topic": "sequence diagram Structured methods",
      "question": "What are the key elements of a Sequence Diagram, and how do they contribute to understanding system behavior? Explain with a Sequence Diagram for 'View Patient Information'.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The key elements of a Sequence Diagram and their contribution to understanding system behavior, along with an example for 'View Patient Information', are as follows:\n\n1.  **Actors:** Represent entities (users, systems, or external components) that interact with the system. In the 'View Patient Information' example, the *Medical Receptionist* is the actor who initiates the process.\n\n2.  **Objects:** Represent the system components or objects involved in the interaction. In the 'View Patient Information' example, key objects include *PatientInfo (P)* (user interface object) and *Database*.\n\n3.  **Lifelines:** Dotted vertical lines extending downwards from actors and objects, representing the timeline during which the actor or object participates in the sequence.\n\n4.  **Messages/Interactions:** Arrows between lifelines indicate messages or interactions between actors and objects. These are annotated to describe the specific action or data being exchanged.  For example, the Medical Receptionist triggers the *ViewInfo* method in the *PatientInfo* object.\n\n5.  **Activation Boxes:** Thin rectangles on lifelines represent the period during which an object is active and processing a message.\n\n6.  **Sequence of Interactions:** The diagram illustrates the chronological order of interactions.  For the 'View Patient Information' use case, the sequence includes:\n *The medical receptionist triggers the ViewInfo method in an instance P of the PatientInfo object class, supplying the patient's identifier, PID.\n *P is a user interface object, which is displayed as a form showing patient information.\n *The instance P calls the database to return the information required, supplying the receptionist's identifier to allow security checking (at this stage, we do not care where this UID comes from).\n *The database checks with an authorization system that the user is authorized for this action.\n *If authorized, the patient information is returned and a form on the user's screen is filled in. If authorization fails, then an error message is returned.\n\n7.  **Authorization System:** Important for security, this element checks user permissions before sensitive data is accessed. In this case, verifying the receptionist’s authorization.\n\n8.  **Error Handling:** Depicted through alternative paths or messages indicating what happens when an action fails (e.g., authorization failure).\n\n9. **Contribution to Understanding System Behavior:**\n *Visualizing Interactions: Sequence diagrams make it easy to visualize and understand complex interactions between different parts of the system.\n *Identifying Dependencies: They help identify dependencies between objects and the sequence of operations required to complete a task.\n *Clarifying Requirements: By modeling interactions, sequence diagrams help clarify and refine system requirements.\n *Design Validation: Sequence diagrams can be used to validate the system design by ensuring that the interactions are logical and efficient.\n *Communication Tool: These diagrams facilitate communication among stakeholders, including developers, testers, and customers.\n\n10. **Alternate Flows:** In the 'View Patient Information' example, an alternate flow occurs if authorization fails, resulting in an error message being displayed instead of the patient information.\n\n11. **System Boundary:** Although not explicitly shown, the sequence diagram helps define the system boundary by illustrating which actors and objects are internal to the system and which are external.\n\n12. **Overall System Understanding:**  By breaking down the 'View Patient Information' use case into a sequence diagram, it becomes easier to understand the steps involved, the objects interacted with, and the overall flow of information within the system."
    },
    {
      "id": 22,
      "module": "MODULE-3",
      "topic": "Model driven engineering Applications",
      "question": "Illustrate the concept of Model Driven Engineering. What are its benefits and challenges?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Model-Driven Engineering (MDE) is a software development approach where models, rather than programs, are the primary outputs. The executable programs are then automatically generated from these models.\n\n**Benefits of MDE:**\n\n1.  **Higher Level of Abstraction:** MDE allows systems to be considered at higher levels of abstraction. Engineers do not need to focus on programming language details or the specifics of execution platforms.\n2.  **Platform Adaptability:** Generating code automatically means it is cheaper to adapt systems to new platforms.\n\n**Challenges of MDE:**\n\n1.  **Translator Development Costs:** Savings from automatic code generation may be outweighed by the costs of developing translators for new platforms.\n2.  **Abstraction vs. Implementation:** Models suitable for abstraction may not be ideal for implementation.\n3.  **Agile Incompatibility:** Extensive up-front modeling contradicts the fundamental ideas in the agile manifesto, potentially making agile developers uncomfortable with model-driven engineering.\n\n**Model Driven Architecture (MDA):**\nMDA is a model-focused approach to software design and implementation that uses a subset of UML models to describe a system. Models at different levels of abstraction are created to achieve a working program from a high-level, platform-independent model without manual intervention.\n\n**Types of Models in MDA:**\n\n1.  **Computation Independent Model (CIM):** Models the important domain abstractions used in a system (domain models).\n2.  **Platform Independent Model (PIM):** Models the operation of the system without reference to its implementation. It is usually described using UML models that show the static system structure and how it responds to external and internal events.\n3.  **Platform Specific Models (PSM):** Transformations of the platform-independent model with a separate PSM for each application platform. Layers of PSM can be added, with each layer adding some platform-specific detail.\n\n**Agile Methods and MDA:**\n\nMDA developers claim it supports an iterative approach to development and can be used within agile methods. If transformations can be completely automated and a complete program generated from a PIM, MDA could be used in an agile development process as no separate coding would be required."
    },
    {
      "id": 23,
      "module": "MODULE-3",
      "topic": "Use case diagrams, which show the interactions between \n a system and its environment.",
      "question": "Explain the difference between a context model and a use case model and how they complement each other.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "A context model illustrates the operational context of a system, showing what lies outside the system boundaries and its relationship with other systems. It helps define the scope of the system and understand its environment. Architectural models often accompany context models to show these relationships.\n\nA use case model, on the other hand, focuses on the interactions between a system and its environment. Each use case represents a discrete task involving external interaction, with actors (people or other systems) interacting with the system to perform specific functions.\n\nHow they complement each other:\n\n1.  **Defining System Boundaries:** Context models help establish system boundaries by showing external entities, while use case models detail interactions within those boundaries.\n2.  **Understanding System Usage:** Context models provide a high-level view of the system's place in its environment, while use case models describe specific ways users interact with the system.\n3.  **Requirements Elicitation:** Use case models are used to support requirements elicitation. The use cases represent discrete tasks that involve interaction with a system.\n4.  **Interaction Modeling:** Both models contribute to understanding interactions; context models show system-to-system interactions, and use case models detail user-system interactions.\n5.  **Visual Representation:** Both models can be represented diagrammatically using UML. Use case diagrams provide an overview of the use cases, and context models show the system and its relationship with other systems.\n6.  **Detailed Textual Form:** Use cases are not only represented diagrammatically but also in a more detailed textual form, complementing the visual overview."
    },
    {
      "id": 24,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "What is test-driven development (TDD), and illustrate with an example how it helps improve code reliability?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Test-driven development (TDD) is an approach where tests are written before the code itself. This is an agile technique that aims to improve software quality and responsiveness to changing requirements through frequent releases and strong collaboration between developers and customers. \n\nHere's how TDD improves code reliability (Illustrated with key points and an example):\n\n1.  **Test-First Approach**: In TDD, tests are written *before* the code. This means the developer must first think about the desired behavior of the code and express it in the form of a test.  (Module 2, page 20)\n2.  **Clarified Requirements**: Writing tests first forces a clearer understanding of requirements, reducing misunderstandings and ambiguities. (Module 4, page 45; Module 5, page 57)\n3.  **Early Defect Detection**: Because tests are run frequently, problems are caught early in the development cycle. (Module 2, page 21; Module 4, page 45)\n4.  **Reduced \"Test-Lag\"**:  TDD avoids the situation where testing is left to the end of the development cycle, leading to delays in finding and fixing bugs. (Module 2, page 21)\n5.  **Automated Testing**: TDD encourages the use of automated testing frameworks (e.g., JUnit), making it easier to run tests quickly and often. (Module 2, page 21)\n6.  **Maintainability**: TDD promotes code refactoring to keep the code clean, simple, and easier to change later. (Module 2, page 19)\n7.  **Continuous Integration**: TDD is often used with continuous integration, where code is integrated and tested daily to detect issues early. (Module 2, page 12)\n8.  **Quality**: XP practices like pair programming and test-first development (TDD) are used to maintain quality. (Module 2, page 14)\n\n**Example Scenario (Module 4, page 106, expanded for TDD context): ATM Machine - Withdraw Cash**\n\n*   **Requirements**: User should be able to withdraw cash successfully from an ATM.\n\n*   **TDD Steps**:\n    *   **Write Test**: Before writing *any* code, write a test case that *fails* because the functionality doesn't exist yet.\n        *   *Test Case*: `testWithdrawalSuccessful()` - Asserts that when a valid card is inserted, the correct PIN is entered, a withdrawal amount is specified within the account balance, then cash is dispensed, a receipt is printed, and the account balance is updated correctly.\n    *   **Write Minimal Code**: Write the *minimum* amount of code needed to pass the test.\n        *   This involves creating classes/methods to handle card insertion, PIN verification, balance check, cash dispensing, receipt printing, and balance update. Start with empty or stub implementations.\n    *   **Run Test**: Run the test. It should now pass (if not, adjust the code until it does).\n    *   **Refactor**: Clean up the code (remove duplication, improve readability) *without* changing its behavior. Ensure all tests still pass after refactoring.\n    *   **Add More Tests**: Add more tests to cover different scenarios (e.g., invalid card, incorrect PIN, insufficient funds, ATM out of cash). Each new test will drive the implementation of new or refined functionality.\n\nBy following TDD, the code for the ATM withdrawal feature is built incrementally, with each increment verified by an automated test. This significantly improves code reliability, reduces bugs, and ensures the code behaves as expected under various conditions."
    },
    {
      "id": 25,
      "module": "MODULE-4",
      "topic": "Software Design",
      "question": "What is a design pattern? Identify the four essential elements of design patterns. Outline any four patterns used in design problems.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "A design pattern is a way of reusing abstract knowledge about a problem and its solution. It provides a description of the problem and the essence of its solution, which is sufficiently abstract to be reused in different settings. Pattern descriptions often use object-oriented characteristics like inheritance and polymorphism.\n\nThe four essential elements of a design pattern are:\n\n1.  **Name:** A meaningful pattern identifier.\n2.  **Problem description:** Defines the context and issue that the pattern addresses.\n3.  **Solution description:** A template for a design solution, not a concrete design, that can be instantiated in different ways.\n4.  **Consequences:** The results and trade-offs of applying the pattern.\n\nFour patterns used in design problems:\n\n1.  **Observer Pattern:** This pattern separates the display of object state from the object itself. It is used when multiple displays of state are needed. A UML description is available in the notes. Consequences of using this pattern include potential impracticality of optimizations to enhance display performance.\n2.  **Facade Pattern:** This pattern is used to tidy up the interfaces to a number of related objects that have often been developed incrementally. It provides a simplified interface to a more complex subsystem.\n3.  **Iterator Pattern:** This pattern provides a standard way of accessing the elements in a collection, irrespective of how that collection is implemented. This allows you to traverse a collection of objects without exposing its underlying structure.\n4.  **Decorator Pattern:** This pattern allows for the possibility of extending the functionality of an existing class at run-time. It enables adding responsibilities to objects dynamically and flexibly."
    },
    {
      "id": 26,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "What is Component Testing? Outline the different types of interface errors that can occur. Also list interface testing guidelines.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "PARTIAL",
      "answer": "**Component Testing:**\nComponent testing is usually done by programmers during development. In incremental development, each part is tested as it's built. It detects faults due to interface errors or invalid assumptions about interfaces.\n\n**Different Types of Interface Errors:**\n1.  **Interface misuse:** A calling component calls another component and makes an error in its use of its interface (e.g., parameters in the wrong order).\n2.  **Interface misunderstanding:** A calling component embeds assumptions about the behavior of the called component which are incorrect.\n3.  **Timing errors:** The called and the calling component operate at different speeds and out-of-date information is accessed.\n\n**Interface Testing Guidelines:**\n\nThe objectives are to detect faults due to interface errors or invalid assumptions about interfaces.\n\n**Interface Types:**\n1.  **Parameter interfaces:** Data passed from one method or procedure to another.\n2.  **Shared memory interfaces:** Block of memory is shared between procedures or functions.\n3.  **Procedural interfaces:** Sub-system encapsulates a set of procedures to be called by other sub-systems.\n4.  **Message passing interfaces:** Sub-systems request services from other sub-systems."
    },
    {
      "id": 27,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "What is user testing? Examine the six stages of the acceptance testing process with a neat diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEPM Questions.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "PARTIAL",
      "answer": "User testing is not explicitly defined in the provided notes. However, it can be inferred as part of the broader concept of software validation.\n\nAcceptance testing is a type of testing mentioned within the context of software validation, where the software is evaluated to ensure it meets user needs and conforms to requirements. The six stages of the acceptance testing process are not provided in the notes. Thus, a neat diagram cannot be generated from the given information.\n\nBased on the notes, here is the available information:\n\n1.  **Software Validation:** Ensuring the software meets user needs and conforms to requirements. Involves activities like unit testing, integration testing, system testing, and acceptance testing. The goal is to detect and fix errors before deployment. (module1.pdf, Page 10)\n\n2.  **Validation:** Checks if the final software meets the customer’s real needs. Focus is on product quality. Methods include testing (unit, integration, system, acceptance), prototyping, and user feedback sessions. (module3.pdf, Page 43)\n\n3.  **Process of V&V in Software Engineering:**\n\n    *   Requirements Verification → Check if requirements are clear, complete, and consistent.\n    *   Design Verification → Check design matches requirements.\n    *   Code Verification → Static checks, code reviews.\n    *   Validation Testing → Unit, integration, system, acceptance testing.\n    *   Final Validation → Ensure delivered product meets user needs in a real environment. (module3.pdf, Page 44)\n\n4.  **Stages in the testing process:**\n\n    *   Component Testing – Each part is tested alone by developers using tools like JUnit.\n    *   System Testing – All parts are combined and tested for interaction issues and requirements.\n    *   Customer Testing – Real users test the system with real data to find missing or unclear requirements. (module3.pdf, Page 51)\n\n5.  **Validation techniques:**\n\n    *   Requirements reviews: The requirements are analyzed systematically by a team of reviewers who check for errors and inconsistencies.\n    *   Prototyping: This involves developing an executable model of a system and using this with end-users and customers to see if it meets their needs and expectations. Stakeholders experiment with the system and feed back requirements changes to the development team.\n    *   Test-case generation: Requirements should be testable. If the tests for the requirements are devised as part of the validation process, this often reveals requirements problems. (module4.pdf, Page 97)\n\nRefer notes for diagram."
    },
    {
      "id": 28,
      "module": "MODULE-1",
      "topic": "Software engineering",
      "question": "What is Software Engineering?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Software engineering is an engineering discipline that is concerned with all aspects of software production from the early stages of system specification through to maintaining the system after it has gone into use. It is important for two reasons: People need software that is fast, low-cost, and works well and using good software methods saves money and avoids costly fixes later. There are two key phrases in this definition:\n1. Engineering discipline\n2. All aspects of software production"
    },
    {
      "id": 29,
      "module": "MODULE-1",
      "topic": "Software engineering",
      "question": "Briefly discuss the need for Software Engineering.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Software engineering is essential for governments, societies, and global businesses because modern infrastructure, utilities, and electronics rely heavily on software systems. Industries like manufacturing, finance, and entertainment are fully software-driven, with over 75% of the global population using software-controlled mobile phones. Software engineering is needed to ensure software is fast, low-cost, and works well. Good software engineering methods save money and avoid costly fixes later. Reports of software project failures are still common due to increasing system complexity and failure to use software engineering methods. The notion of software engineering was proposed in 1968 because small programming methods didn’t work well for large, complex systems, which were unreliable, expensive, and delivered late."
    },
    {
      "id": 30,
      "module": "MODULE-1",
      "topic": "Introduction",
      "question": "Discuss the four important attributes of good software and ethical responsibilities that all software professionals should have.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the provided notes, here's a discussion of the four important attributes of good software and ethical responsibilities for software professionals:\n\n**Four Important Attributes of Good Software:**\n\nThe notes do not explicitly list \"four important attributes of good software.\" However, characteristics of agility and software quality aspects are mentioned which can be construed as desirable attributes.\n\n1.  **Flexibility:** The ability to adapt to changing customer needs, market demands, or technology. Plans are not rigid, and changes can be incorporated at any stage. This means good software should be adaptable and easily modified to accommodate new requirements or address unforeseen issues.\n\n2.  **Customer Focus:** Software should be built around user needs and expectations. This attribute emphasizes the importance of understanding and prioritizing customer requirements throughout the development process.\n\n3.  **Technical Excellence:** Good software should promote clean code, good design, and thorough testing for maintainability and scalability.  This implies a focus on code quality, adherence to coding standards, and the use of appropriate development practices.\n\n4.  **Reliability:** The wilderness weather station case study mentions that the system must be reliable. Dependability is also mentioned under Non-Functional requirements which includes reliability, availability, and fault tolerance.\n\n**Ethical Responsibilities of Software Professionals:**\n\nSoftware engineering ethics are explicitly covered in the notes, outlining key responsibilities that professionals should uphold:\n\n1.  **Confidentiality:** Software professionals have a responsibility to maintain the confidentiality of sensitive information they encounter during their work. This includes protecting trade secrets, customer data, and other confidential information from unauthorized access or disclosure.\n\n2.  **Competence:** Software engineers should not misrepresent their level of competence.  This implies honesty about one's skills and experience, as well as a commitment to continuous learning and professional development.\n\n3.  **Intellectual Property Rights:** Software professionals must respect intellectual property rights, including patents and copyrights. This means avoiding plagiarism, properly licensing software, and respecting the ownership of code and other creative works.\n\n4.  **Computer Misuse:** Software engineers should not use their technical skills to misuse other people’s computers or systems.  This encompasses activities such as hacking, spreading malware, and engaging in other forms of cybercrime."
    },
    {
      "id": 31,
      "module": "MODULE-1",
      "topic": "Introduction",
      "question": "List out the difference between generic and customized products.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Generic products:\n*   They are standalone systems created to be sold to anyone on the open market.\n*   Examples: mobile apps and word processors.\n\nCustomized (or bespoke) software:\n*   Customized software is made for a specific customer.\n*   Examples: control systems, business tools, and air traffic control systems."
    },
    {
      "id": 32,
      "module": "MODULE-1",
      "topic": "Software engineering",
      "question": "What is the difference between Software Engineering and Computer Science?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the provided notes, Computer Science is concerned with the theories and methods that underlie computers and software systems. It focuses on the theoretical aspects of computation.\n\nSoftware Engineering, on the other hand, is concerned with the practical problems of producing software. It is an engineering discipline involved with all aspects of software production from system specification to maintaining the system after it has gone into use. Software engineering is a structured way to build software, focusing on cost, time, quality, and user needs."
    },
    {
      "id": 33,
      "module": "MODULE-1",
      "topic": "Software engineering",
      "question": "Compare the terms Software Engineering and System Engineering.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Software Engineering and System Engineering are related but distinct disciplines. Here's a comparison based on the provided notes:\n\n1.  **Definition**: Software engineering is an engineering discipline concerned with all aspects of software production, from initial system specification to maintenance after deployment (module1.pdf, page 8). System engineering deals with building and improving complex systems that include software, hardware, rules, and setup (module1.pdf, page 11).\n\n2.  **Scope**: Software engineering focuses specifically on software systems and their development lifecycle. System engineering has a broader scope, encompassing all elements of a system, including hardware, software, and human factors (module1.pdf, page 11).\n\n3.  **Focus**: Software engineering is concerned with the practical problems of producing software (module1.pdf, page 11). System engineering focuses on integrating software into a larger system context (module1.pdf, page 11).\n\n4.  **Activities**: Both involve specification, design, development, validation, and evolution (module1.pdf, pages 9, 10). However, system engineering also considers hardware integration, system architecture, and overall system performance (module1.pdf, page 11).\n\n5.  **Relationship**: Software engineering is a subset of system engineering. System engineering often includes software engineering as a component (module1.pdf, page 11).\n\n6.  **Complexity**: Both disciplines address increasing system complexity, but system engineering deals with complexity at a higher level, considering interactions between different system components (module1.pdf, page 3).\n\n7.  **Engineering Discipline**: Software engineering is explicitly defined as an engineering discipline, emphasizing structured and methodical approaches to software production (module1.pdf, page 8). System engineering, by definition, is an engineering discipline (module1.pdf, page 11).\n\n8.  **System Specification**: Both disciplines start with system specification. In software engineering, this involves defining what the software should do and its constraints (module1.pdf, page 9). In system engineering, this involves defining the overall system requirements, including hardware and software components (module1.pdf, page 11).\n\n9.  **Practical Problems**: Software engineering deals with the practical problems of producing software (module1.pdf, page 11). System engineering addresses practical challenges in integrating and managing complex systems (module1.pdf, page 11).\n\n10. **Examples**: Examples provided in the notes relate more towards software applications, no examples are available for System Engineering. Software engineering is used in mobile apps, word processors, control systems, business tools, and air traffic control systems (module1.pdf, page 5). System engineering principles apply to larger infrastructures and utilities (module1.pdf, page 2).\n\nIn summary, while software engineering concentrates on the software components of a system, system engineering takes a holistic view, integrating software, hardware, and other elements to achieve overall system objectives."
    },
    {
      "id": 34,
      "module": "MODULE-5",
      "topic": "Web links and Video Lectures (e-Resources)",
      "question": "Explain briefly the web-based software engineering methods and tools used.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the provided notes, there is no specific section dedicated to \"web-based software engineering methods and tools.\" However, the notes do contain information about software engineering methods and tools that could be used in web-based software engineering, along with general software project management principles and some specific internet related tools. Here's a summary:\n\n1.  **Software Engineering Methods:** The notes describe several software process models, including the Waterfall model, Incremental development, and Integration & Configuration. Agile methods like Extreme Programming (XP) and Scrum are also discussed. These methods could be applied to web-based software engineering projects.\n\n2.  **Internet Software Engineering:**  Software is used online as a service and runs on the cloud. Software development has changed by reusing existing parts, improving step by step, using web services and tools like AJAX and HTML5 help to create better web apps. (module1.pdf)\n\n3.  **Agile Development Techniques:** Agile methods are well-suited for web development due to their flexibility and iterative nature. XP practices include frequent releases, pair programming, test-first development, user stories, and continuous integration. Scrum, with its sprints and daily scrum meetings, provides a structured approach to agile project management. (module2.pdf)\n\n4.  **Tools:** Common tools include planning tools, design tools, code editors, testing tools and debug tools. (module3.pdf)\n\n5.  **Scrum Tools:** Scrum utilizes tools such as a Product Backlog, Sprint Backlog, Daily Scrum meetings, and Scrum Board to manage and track project progress in an agile environment.\n\n6.  **Model-Driven Engineering (MDE):** The notes mention Model-Driven Engineering (MDE) where models, rather than programs, are the principal outputs. \n\n7. **Configuration Management:** This includes version management, system integration, and problem tracking using integrated development environments (IDEs). \n\n8. **Test Automation Tools:** JUnit assists in automating testing and maintaining quality.\n\n9. **Testing tools:** Such as  component testing, system testing, customer testing are required.\n\n10. **Requirements Engineering:** Elicitation & analysis, specification and validation. (module4.pdf)"
    },
    {
      "id": 35,
      "module": "MODULE-2",
      "topic": "Software Process activities, Agile software Development and Requirements Analysis (8 hours) Process activities",
      "question": "Briefly explain the four fundamental activities common to all software processes.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The four fundamental activities common to all software processes are:\n\n1.  **Software specification:** This involves defining what the software should do and the constraints it must adhere to. It includes gathering requirements, analyzing them, and documenting them meticulously. Stakeholders, users, and engineers work together to specify functional requirements (what the system should do) and non-functional requirements (performance, security, reliability, etc.).\n\n2.  **Software development:** This activity translates the software specification into an executable system. It includes system design, where the architecture, data structures, and interfaces are created, and implementation (coding) in a programming language. The focus is on converting ideas and requirements into working software.\n\n3.  **Software validation:** This ensures that the software meets user needs and conforms to the specified requirements. It encompasses activities such as unit testing, integration testing, system testing, and acceptance testing. The primary goal is to detect and fix errors before the software is deployed.\n\n4.  **Software evolution:** Software is rarely \"finished\" after its initial release. This activity involves adapting the software to accommodate changing requirements, fixing issues that arise, and improving its overall performance. It includes corrective maintenance (fixing bugs), adaptive maintenance (adapting to new environments), perfective maintenance (improving performance or design), and preventive maintenance (reducing the likelihood of future problems).\n\nTogether, these activities form the software life cycle, ensuring the software product is useful, reliable, and adaptable."
    },
    {
      "id": 36,
      "module": "MODULE-1",
      "topic": "Software engineering",
      "question": "Explain the essential attributes of good software.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Good software should possess essential attributes that ensure its effectiveness and user satisfaction. While the notes don't explicitly list \"essential attributes of good software,\" several characteristics can be inferred from various sections. Here's a detailed explanation based on the provided context:\n\n1.  **Functionality and Reliability:** Software must meet the specified requirements and perform its intended functions correctly and reliably (Page 9, 18). In the context of an insulin pump (Page 19), this means always being ready to deliver insulin when needed and providing the right amount.\n\n2.  **Usability:** The software should be easy to use and understand (Page 60). User-friendliness enhances user satisfaction and reduces errors.\n\n3.  **Efficiency and Performance:** Software should utilize system resources effectively and provide timely responses (Page 62). Fast, low-cost operation is a key reason for employing good software methods (Page 9).\n\n4.  **Maintainability:** The software should be easy to maintain, update, and adapt to changing requirements (Page 18). This includes fixing bugs, improving performance, and incorporating new features (Page 10).\n\n5.  **Security:** Protecting against unauthorized access and data breaches is crucial (Page 62). Security measures ensure the confidentiality and integrity of data.\n\n6.  **Scalability:** Software should be able to handle increasing workloads and user demands without significant performance degradation (Page 4). The ability to scale ensures long-term viability.\n\n7.  **Adaptability:** Software should be adaptable to different devices and platforms (Page 11). Heterogeneity ensures the software works across various environments.\n\n8.  **Cost-Effectiveness:** Using good software engineering methods saves money and avoids costly fixes later (Page 9). Cost considerations are vital for project success.\n\n9.  **Timeliness:** Delivering software on time is critical (Page 12). Delays can lead to project failures.\n\n10. **Testability:** The software should be designed in a way that it can be easily tested. Requirements should be written so that they are verifiable (Page 96).\n\n11. **Flexibility**: Should be able to adapt to changing customer needs, market demands, or technology (Page 4).\n\n12. **Collaboration**: Emphasizes teamwork between developers, testers, business analysts, and customers. (Page 4)\n\n13. **Simplicity**: Build only what’s necessary to meet user needs. (Page 4)"
    },
    {
      "id": 37,
      "module": "MODULE-3",
      "topic": "Behavioral Models -Data driven modeling",
      "question": "With a neat diagram, explain the activity model of the insulin pump control system.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Refer notes for diagram.\n\nBased on the notes, the activity model of the insulin pump control system illustrates the sequence of actions involved in the pump's operation. The diagram should show the flow of data and control within the system. Here's a detailed breakdown of what the activity model should represent:\n\n1.  **Microsensor Blood Sugar Check**: A microsensor continuously monitors the patient's blood sugar level.\n\n2.  **Controller Calculation**: The controller receives the blood sugar data from the microsensor and calculates the amount of insulin needed.\n\n3.  **Mini Pump Pulses**: The controller sends pulses to a mini pump based on the calculated insulin requirement. For example, 10 pulses may equate to 10 units of insulin.\n\n4.  **Insulin Injection**: The mini pump injects the required amount of insulin into the patient.\n\n5.  **Insulin Reservoir**: Stores the insulin supply and is connected to the pump for insulin delivery.\n\n6.  **Pump Mechanism**: Pushes insulin from the reservoir into the needle assembly for injection.\n\n7.  **Needle Assembly**: Delivers insulin directly into the patient’s body.\n\n8.  **Sensor Data Transmission**: The sensor continuously monitors the blood glucose level and sends readings to the controller.\n\n9.  **Clock Input**: The controller uses timing information from the clock for scheduled insulin delivery (basal doses).\n\n10. **Decision Making**: The controller decides when and how much insulin to deliver based on sensor data and clock input.\n\n11. **Signal Transmission**: The controller sends signals to the pump, displays, and alarm.\n\n12. **Alarm Trigger**: The alarm alerts the patient in case of abnormal conditions such as low battery, blocked needle, or dangerously high/low glucose level.\n\n13. **Display Information**: Displays (Display1 & Display2) show information to the patient, such as glucose level, insulin dose, battery status, and error messages.\n\n14. **Power Supply**: Provides electrical energy to the entire system for functioning.\n\nThe system must always be ready to give insulin when needed and must work properly to give the right amount of insulin."
    },
    {
      "id": 38,
      "module": "MODULE-1",
      "topic": "Software engineering",
      "question": "What are some general issues facing software engineering?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the provided notes, some general issues facing software engineering include:\n\n1.  **Increasing System Complexity:** Software projects are failing due to the increasing complexity of systems.\n2.  **Failure to Use Software Engineering Methods:** Projects also fail when appropriate software engineering methods are not employed.\n3.  **Heterogeneity:** Software needs to operate across diverse devices such as phones, tablets, and computers.\n4.  **Business and Social Change:** Software must adapt to evolving business needs and societal changes.\n5.  **Security and Trust:** Ensuring the security and trustworthiness of software is a critical challenge.\n6.  **Scale:** Handling the development and maintenance of large-scale software systems poses significant engineering challenges.\n7. **Confidentiality** Software engineering must handle confidential data appropriately.\n8. **Competence:** Software engineers must represent their level of competence accurately.\n9. **Intellectual property rights:** Software engineers must respect patents and copyrights.\n10. **Computer misuse:** Software engineers should not use their technical skills to misuse other people’s computers."
    },
    {
      "id": 39,
      "module": "MODULE-1",
      "topic": "Applications",
      "question": "What are the different application types?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the notes, there are different types of application. They are:\n\n1.  Stand-alone applications (Example: Microsoft Office).\n2.  Interactive transaction-based applications (Example: e-commerce applications).\n3.  Embedded control systems (Examples: software in a mobile phone, software that controls antilock braking in a car, and software in a microwave oven).\n4.  Batch processing systems (Example: salary payment systems).\n5.  Entertainment systems (Examples: games that run on special-purpose console hardware).\n6.  Systems for modeling and simulation (Examples: Weather or Traffic).\n7.  Data collection and analysis systems (Example: weather monitoring system).\n8.  Systems of systems (Example: ERP software)."
    },
    {
      "id": 40,
      "module": "MODULE-1",
      "topic": "Software engineering",
      "question": "What is the rationale for the ACM/IEEE code of ethics?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "PARTIAL",
      "answer": "I am sorry, but I cannot answer this question because the provided notes do not contain the rationale for the ACM/IEEE code of ethics."
    },
    {
      "id": 41,
      "module": "MODULE-1",
      "topic": "Introduction",
      "question": "List any five ethical principles.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the provided notes (module1.pdf, page 16):\n\nFive ethical principles for software engineering are:\n\n1.  Confidentiality\n2.  Competence: You should not misrepresent your level of competence.\n3.  Intellectual property rights: Patents and copyrights.\n4.  Computer misuse: You should not use your technical skills to misuse other people’s computers."
    },
    {
      "id": 42,
      "module": "MODULE-1",
      "topic": "Introduction",
      "question": "Explain the four related issues that affect many different types of software regarding professional responsibility.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The four related issues that affect many different types of software are:\n\n1.  **Heterogeneity:** Software should work on many devices like phones, tablets, and computers.\n2.  **Business and social change**\n3.  **Security and trust**\n4.  **Scale**"
    },
    {
      "id": 43,
      "module": "MODULE-1",
      "topic": "Software engineering",
      "question": "Discuss the reasons why software projects fail and explain software costs.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Software projects often fail due to two primary reasons: increasing system complexity and failure to use software engineering methods. As systems become more intricate, the challenges in managing their development, integration, and maintenance amplify significantly. Without employing robust software engineering methods, projects are more susceptible to errors, delays, and cost overruns.\n\nSoftware costs can be understood through the lens of the software lifecycle, which encompasses several fundamental activities:\n\n1.  **Software Specification:** This involves defining what the software should do and its constraints. It includes gathering requirements, analysis, and documentation. Stakeholders, users, and engineers collaborate to specify functional and non-functional requirements.\n2.  **Software Development:** This consists of converting the specification into an executable system. System design (architecture, data structures, interfaces) and implementation (coding) in a programming language are integral to this activity. It focuses on transforming ideas and requirements into working software.\n3.  **Software Validation:** This phase ensures that the software meets user needs and conforms to the requirements. Activities include unit testing, integration testing, system testing, and acceptance testing. The primary goal is to detect and fix errors before deployment.\n4.  **Software Evolution:** Software is rarely \"finished\" after its initial release. This activity involves adapting software to changing requirements, fixing issues, and improving performance. It includes corrective, adaptive, perfective, and preventive maintenance.\n\nSoftware projects may incur costs related to the following:\n\n*   **Development Costs:** These encompass expenses related to the design, coding, and testing phases.\n*   **Maintenance Costs:** These involve the expenses associated with fixing bugs, adding new features, and adapting the software to changing requirements.\n*   **Personnel Costs:** Salaries and benefits for developers, project managers, testers, and other team members contribute significantly to the overall cost.\n*   **Tool Costs:** Expenses for development tools, testing software, and other software needed for development."
    },
    {
      "id": 44,
      "module": "MODULE-1",
      "topic": "Introduction",
      "question": "Give two examples of ethical dilemmas.",
      "marks": 2,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Two examples of ethical dilemmas are confidentiality, where you must keep sensitive information private, and computer misuse, where you should not use your technical skills to misuse other people’s computers."
    },
    {
      "id": 45,
      "module": "MODULE-1",
      "topic": "Introduction",
      "question": "What differences has the web made to software engineering?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the provided notes, here are the differences the web has made to software engineering:\n\n1.  **Software as a Service:** Software is now frequently delivered online as a service (e.g., Google Apps), indicating a shift from traditional software distribution methods to cloud-based services.\n2.  **Cloud-Based Execution:** Software now commonly runs on the cloud, leveraging cloud infrastructure for execution and scalability. Payment models have also shifted to usage-based or ad-supported.\n3.  **Reuse of Existing Parts:** A significant change involves creating new software by reusing existing components. This emphasizes component-based development rather than building systems from scratch.\n4.  **Incremental Improvement:** Software is built and improved step by step, reflecting an iterative development approach that allows for continuous refinement.\n5.  **Web Services Utilization:** Modern software engineering utilizes web services, which are accessed remotely over the Internet.\n6.  **Improved Web App Tools:** Tools like AJAX and HTML5 are used to create better web applications. This suggests advancements in technology to enhance the functionality and user experience of web-based software.\n7.  **Agile Methods:**  The notes indicate that agile methods emerged in response to the problems of plan-driven methods. Agile practices are often now favored. Agile emphasizes quick responses to change and iterative development.\n8.  **Component-Based Development:** The process model for reuse-based development is based on integration and configuration, defining stages such as requirements specification, software discovery and evaluation, and requirements refinement. This highlights the importance of leveraging existing components in software development.\n9.  **Application Types:** Interactive transaction-based applications, like e-commerce apps, are identified as a distinct application type, showcasing the impact of the web on software applications.\n10. **Internet Software Engineering:** The rise of online software is explicitly acknowledged as a key trend, emphasizing the importance of engineering practices tailored for web-based applications."
    },
    {
      "id": 46,
      "module": "MODULE-1",
      "topic": "Applications",
      "question": "Describe any two concerns of a software system for mental health care.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Two concerns of a software system for mental health care, as described in the notes with reference to the Mentcare system, are:\n\n1.  **Data protection laws:** The system must adhere to data protection laws to ensure patient information is handled securely and confidentially. This is crucial for maintaining patient privacy and trust.\n2.  **Mental health laws:** The system must comply with mental health laws, which likely involve specific regulations regarding the storage, access, and use of patient data related to mental health treatments and conditions."
    },
    {
      "id": 47,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "List two types of reusable software.",
      "marks": 2,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the notes, two types of reusable software components are: standalone applications adapted for specific environments and object/component packages integrated with frameworks."
    },
    {
      "id": 48,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "What are the advantages and disadvantages of reuse oriented software?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "PARTIAL",
      "answer": "Based on the provided notes, the following information pertains to the advantages and disadvantages of reuse oriented software:\n\n**Advantages:**\n\n1.  **Time and Effort Savings:** Software is often built by reusing existing parts to save time and effort. (module1.pdf, Page 51)\n\n**Disadvantages (Implied Challenges):**\n\n1.  **Discovery and Evaluation Costs:** The notes mention costs associated with searching for software to reuse and assessing whether it meets needs. (Module4.pdf, Page 39)\n2.  **Acquisition Costs:** There could be a cost in acquiring reusable software, for large off-the-shelf systems, these costs can be very high. (Module4.pdf, Page 39)\n3.  **Adaptation and Configuration Costs:** The notes mention costs of adapting and configuring the reusable software components or systems to reflect the requirements of the system that is being developed. (Module4.pdf, Page 39)\n4.  **Integration Costs:** The notes mention costs of integrating reusable software elements with each other (if software is from different sources) and with the new code. (Module4.pdf, Page 39)\n\nThese points highlight that while reuse oriented software development can be beneficial, it also presents certain challenges and costs that must be considered."
    },
    {
      "id": 49,
      "module": "MODULE-1",
      "topic": "The waterfall model, Incremental development, Integration and configuration",
      "question": "Discuss the Waterfall Model in detail with the aid of a diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The Waterfall Model is a linear and sequential software development approach where each phase must be completed before moving to the next. Refer notes for diagram.\n\n1.  **Requirements Definition:** This initial phase involves gathering and documenting all functional and non-functional requirements of the software. The output is a Software Requirement Specification (SRS) document.\n\n2.  **System and Software Design:** Based on the SRS, the system architecture and software design are created. This includes high-level design (system architecture) and low-level design (module details). The output is design documents that guide implementation.\n\n3.  **Implementation and Unit Testing:** Developers write code based on the design documents. Each module is tested individually (unit testing) to ensure it works as intended. The output is verified program modules.\n\n4.  **Integration and System Testing:** All modules are integrated into a complete system. System testing ensures the entire software meets requirements and works correctly. Defects are identified and fixed during this phase.\n\n5.  **Operation and Maintenance:** The software is deployed to users and enters operational use. Maintenance includes fixing bugs, updating features, and improving performance as needed. This may require repeating earlier steps.\n\n**Key Characteristics:**\n\n*   **Linear and Sequential:** Phases are completed in order, with one phase finishing before the next starts.\n*   **Plan-Driven:** All activities are planned before development begins.\n\n**Advantages:**\n\n*   Simple and easy to understand.\n*   Clear structure with well-defined stages.\n*   Works well for small projects with fixed requirements.\n\n**Disadvantages:**\n\n*   Not flexible if requirements change.\n*   Difficult to change things once a step is finished.\n*   Testing happens late, so problems are found late.\n*   Customers see the product only at the end.\n\n**Best Suited For:**\n\n*   Embedded systems where software must match fixed hardware.\n*   Critical systems that need complete documents for safety and security checks.\n*   Large projects with many companies that need detailed plans so each can work separately."
    },
    {
      "id": 50,
      "module": "MODULE-1",
      "topic": "The waterfall model, Incremental development, Integration and configuration",
      "question": "Write down the advantages and disadvantages of the waterfall model.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Advantages of the Waterfall Model:\n\n*   Simple and easy to understand (module1.pdf, page 44).\n*   Clear structure with well-defined stages (module1.pdf, page 44).\n*   Works well for small projects with fixed requirements (module1.pdf, page 44).\n\nDisadvantages of the Waterfall Model:\n\n*   Not flexible if requirements change (module1.pdf, page 44).\n*   Hard to change things once a step is finished (module1.pdf, page 44).\n*   Testing happens late, so problems are found late (module1.pdf, page 44).\n*   Customers see the product only at the end (module1.pdf, page 44)."
    },
    {
      "id": 51,
      "module": "MODULE-1",
      "topic": "Incremental development, Integration and configuration",
      "question": "Explain the Incremental Model with a neat block diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The Incremental Model builds software in small versions, getting feedback and improving it step by step. Specification, development, and testing happen together with quick feedback. This can be plan-driven, agile, or a mix. It is better than the waterfall model for systems where requirements may change.\n\nWorking of Incremental Model:\n\n1.  Outline Description: This is the starting point, a high-level idea or concept of the system.\n2.  Concurrent Activities:\n    These three activities run in parallel and interact with each other:\n    *   Specification: Define system requirements and features. It can be updated based on feedback from development and validation.\n    *   Development: Build the software based on the current specification. It may influence or be influenced by changes in specification and validation.\n    *   Validation: Test and verify the software to ensure it meets requirements. Arrows between these activities show that they communicate and influence each other continuously. Changes in one area can trigger updates in the others.\n3.  Versions of the System: As the concurrent activities progress, they produce different versions:\n    *   Initial Version: First working version based on early specifications.\n    *   Intermediate Versions: Updated versions as development and validation refine the system.\n    *   Final Version: The completed and validated system.\n\nRefer notes for diagram, it should consist of:\n\n1.  Outline Description.\n2.  Concurrent Activities (Specification, Development, Validation).\n3.  Arrows between these activities to show that they communicate and influence each other continuously.\n4.  Versions of the System (Initial Version, Intermediate Versions, Final Version)."
    },
    {
      "id": 52,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "How does agile software development overcome the problems of the waterfall model?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Agile software development overcomes the problems of the waterfall model through several key aspects:\n\n1.  **Flexibility and Adaptability:** Agile emphasizes the ability to respond quickly and effectively to changing customer needs, market conditions, and technological advancements. Unlike the waterfall model's rigid, pre-defined plan, agile plans are adaptable, allowing changes to be incorporated at any stage.\n\n2.  **Customer Focus:** Agile methodologies build the product around user needs and expectations. Regular demos and review meetings with stakeholders ensure continuous feedback and alignment with evolving customer requirements. This contrasts with the waterfall model, where customers typically see the product only at the end.\n\n3.  **Iterative Development:** Agile uses iterative development, dividing work into short cycles (sprints) of 1-4 weeks. Each sprint delivers a usable part of the software, allowing for faster delivery of features compared to the waterfall model's sequential phases.\n\n4.  **Incremental Delivery:** Software is delivered in small increments, enabling early use and feedback. This allows customers to provide feedback by using early versions, not just documents, as in the waterfall model. Incremental delivery ensures that useful software is delivered early, even without full functionality.\n\n5.  **Collaboration:** Agile emphasizes teamwork between developers, testers, business analysts, and customers. Daily stand-ups and cross-functional sprint planning sessions facilitate continuous communication and collaboration, reducing misunderstandings and improving alignment.\n\n6.  **Continuous Improvement:** Agile teams reflect on past work to identify what can be improved and implement improvements in subsequent iterations. Retrospective meetings at the end of each sprint enable continuous improvement.\n\n7.  **Minimal Documentation:** Agile focuses on working software and communication over heavy paperwork, reducing the overhead associated with extensive documentation in the waterfall model.\n\n8.  **Responding to Change:** Agile values responding to change over following a plan, allowing for adjustments to plans and priorities as requirements change. This adaptability addresses the waterfall model's inflexibility and difficulty in accommodating changing requirements.\n\n9.  **Early and Continuous Feedback:** Incremental approach provides frequent opportunities for feedback and collaboration, helping the development team to stay aligned with the customer's expectations and address any issues or concerns promptly.\n\n10. **Test-Driven Development:** Some Agile methodologies, like Extreme Programming (XP), use test-first development, where tests are written before the code. This practice helps catch problems early, reduces misunderstandings, and avoids \"test-lag\"."
    },
    {
      "id": 53,
      "module": "MODULE-2",
      "topic": "Software Process activities, Agile software Development and Requirements Analysis (8 hours) Process activities",
      "question": "Explain the different processes involved in developing software.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The development of software involves several fundamental processes:\n\n1.  **Software Specification:** This process is about defining what the software should do and identifying any constraints. It includes requirement gathering, analysis, and documentation. Stakeholders such as users and engineers collaborate to specify functional (what the system should do) and non-functional requirements (performance, security, reliability, etc.).\n\n2.  **Software Development:** This is the process of converting the software specification into an executable system. It includes system design (architecture, data structures, interfaces) and implementation (coding) in a programming language. The focus is on transforming ideas and requirements into working software.\n\n3.  **Software Validation:** This involves ensuring that the software meets the user's needs and conforms to the specified requirements. It includes activities like unit testing, integration testing, system testing, and acceptance testing. The goal is to detect and fix errors before deployment.\n\n4.  **Software Evolution:** Software is rarely \"finished\" after its initial release. This process involves adapting the software to changing requirements, fixing issues, and improving performance. It includes corrective, adaptive, perfective, and preventive maintenance.\n\nThese activities form the software life cycle, ensuring the product is useful, reliable, and adaptable. General process models include the Waterfall model, Incremental development, and Integration & configuration."
    },
    {
      "id": 54,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "What are the different software process models?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the provided notes, here are the different software process models:\n\n1.  **Waterfall Model:**\n *   Follows sequential phases: requirements definition, system and software design, implementation and unit testing, integration and system testing, and operation and maintenance.\n *   It is a plan-driven process where all activities are planned before development starts.\n *   Best suited for embedded systems, critical systems, and large projects with many companies involved.\n\n2.  **Incremental Development:**\n *   Builds software in small versions, incorporating feedback and improving step by step.\n *   Specification, development, and testing happen concurrently with quick feedback loops.\n *   Can be plan-driven, agile, or a mix of both.\n *   Suited for systems where requirements may change.\n\n3.  **Integration and Configuration:**\n *   Builds software by reusing existing code, often informally by finding and modifying similar code.\n *   Involves stages such as requirements specification, software discovery & evaluation, requirements refinement, and either configuring an application system or adapting/developing new components and integrating them.\n *   Commonly reuses standalone applications, object/component packages, and web services."
    },
    {
      "id": 55,
      "module": "MODULE-1",
      "topic": "Incremental development, Integration and configuration",
      "question": "Discuss in detail the incremental development model with the help of a neat diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The incremental development model builds software in small versions, getting feedback and improving it step by step. Specification, development, and testing happen together with quick feedback. It can be plan-driven, agile, or a mix. It is better than the waterfall model for systems where requirements may change.\n\n**Working of Incremental Model:**\n1.  **Outline Description:** This is the starting point, a high-level idea or concept of the system.\n2.  **Concurrent Activities:**\n    These three activities run in parallel and interact with each other:\n *   **Specification:** Define system requirements and features. It can be updated based on feedback from development and validation.\n *   **Development:** Build the software based on the current specification. It may influence or be influenced by changes in specification and validation.\n *   **Validation:** Test and verify the software to ensure it meets requirements.  Arrows between these activities show that: They communicate and influence each other continuously. Changes in one area can trigger updates in the others.\n3.  **Versions of the System:** As the concurrent activities progress, they produce different versions:\n *   **Initial Version:** First working version based on early specifications.\n *   **Intermediate Versions:** Updated versions as development and validation refine the system.\n *   **Final Version:** The completed and validated system.\n\n**Diagram:** Refer notes for diagram on page 45, which illustrates the incremental development model. The diagram shows Specification, Development, and Validation happening concurrently and iteratively, leading to Initial, Intermediate, and the Final versions of the system. Arrows between Specification, Development and Validation indicate that they interact with each other. This diagram illustrates how the system evolves through multiple increments, incorporating feedback and changes at each stage.  \n\n**Advantages over the waterfall model:**\n1.  Cheaper and easier to handle changes.\n2.  Customers can give feedback by using early versions, not just documents.\n3.  Useful software is delivered early, even without full functionality.\n\n**Problems from a management perspective:**\n1.  Hard for managers to track progress because frequent documentation is costly.\n2.  Code can get messy as new features are added, making future changes harder.\n\n**Additional points:**\n*   Incremental development can gather feedback without delivering each version to customers.\n*   Incremental delivery means deploying the software for real use, giving more realistic feedback."
    },
    {
      "id": 56,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "List the advantages and disadvantages of the model.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Based on the provided notes, the advantages and disadvantages of the Waterfall model are:\n\n**Advantages:**\n*   Simple and easy to understand (module1.pdf, page 44).\n*   Clear structure with well-defined stages (module1.pdf, page 44).\n*   Works well for small projects with fixed requirements (module1.pdf, page 44).\n\n**Disadvantages:**\n*   Not flexible if requirements change (module1.pdf, page 44).\n*   Hard to change things once a step is finished (module1.pdf, page 44).\n*   Testing happens late, so problems are found late (module1.pdf, page 44).\n*   Customers see the product only at the end (module1.pdf, page 44)."
    },
    {
      "id": 57,
      "module": "MODULE-2",
      "topic": "Software Process activities, Agile software Development and Requirements Analysis (8 hours) Process activities",
      "question": "Explain reuse-oriented software engineering with the help of a diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Reuse-oriented software engineering involves creating software by integrating existing components and systems. This approach leverages pre-built assets to reduce development time and effort. Refer notes for diagram.\n\n1.  **Requirements Specification**: Define system needs.\n2.  **Software Discovery & Evaluation**:\n *   **Software Discovery**: Search for existing components or systems.\n *   **Software Evaluation**: Assess suitability, compatibility, and quality.\n3.  **Requirements Refinement**: Refine requirements based on available components.\n4.  **Path A: Application System Available**\n    *   **Configure Application System**: Customize the existing system to meet refined requirements.\n5.  **Path B: Components Available**\n    *   **Adapt Components**: Modify existing parts to fit.\n    *   **Develop New Components**: Build new ones if needed.\n    *   **Integrate System**: Combine all parts into the final system.\n6. **Three commonly reused software components:**\n    *   Standalone applications\n    *   Object/component packages\n    *   Web services"
    },
    {
      "id": 58,
      "module": "MODULE-2",
      "topic": "Requirements engineering Process, Requirement elicitation, Requirement specification, Requirement Validation and management Applications",
      "question": "Explain the requirements engineering process with a diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The requirements engineering process is about defining, documenting, and maintaining the requirements of a software system throughout its lifecycle. It's about capturing what the system should do (functional requirements) and how it should perform (non-functional requirements).\n\nThe requirements engineering process involves iterative activities in a spiral model:\n\n1.  **Elicitation & Analysis:** Discovering requirements from stakeholders. Stages include user requirements elicitation (collecting needs from end-users) and system requirements elicitation (identifying system-level requirements).\n\n2.  **Specification:** Documenting and modeling requirements clearly. Stages include business requirements specification (high-level business goals), user requirements specification (what the users expect from the system), and system requirements specification and modeling (technical and functional details of the system).\n\n3.  **Validation:** Ensuring requirements are correct, complete, and feasible. Stages include feasibility study (can the requirements be realistically implemented?), prototyping (building early versions to validate user needs), and reviews (checking documents and prototypes with stakeholders).\n\nRefer notes for diagram called “A Spiral View of the Requirements Engineering Process” . It represents how requirements are gathered, refined, validated, and documented in a cyclical and iterative manner. The process starts at the center and moves outward as requirements become more detailed and complete. The diagram shows the three main activities (Elicitation, Specification, and Validation) arranged in a spiral, emphasizing the iterative nature of the process and leading to a System Requirements Document (SRD) at the outer edge."
    },
    {
      "id": 59,
      "module": "MODULE-2",
      "topic": "Software Process activities, Agile software Development and Requirements Analysis (8 hours) Process activities",
      "question": "Explain the four fundamental activities common to all software processes.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The four fundamental activities common to all software processes are:\n\n1.  **Software Specification:** This involves defining what the software should do and the constraints it must operate under. It encompasses requirement gathering, analysis, and documentation. Stakeholders, users, and engineers collaborate to specify both functional requirements (what the system should do) and non-functional requirements (performance, security, reliability, etc.).\n\n2.  **Software Development:** This activity focuses on converting the specification into an executable system. It includes system design, which involves defining the architecture, data structures, and interfaces, and implementation, which involves coding the software in a programming language. The primary focus is transforming ideas and requirements into working software.\n\n3.  **Software Validation:** This involves ensuring that the software meets user needs and conforms to the specified requirements. This includes activities like unit testing, integration testing, system testing, and acceptance testing. The goal is to detect and fix errors before deployment.\n\n4.  **Software Evolution:** Software is rarely 'finished' after its initial release. This activity involves adapting the software to changing requirements, fixing issues that arise, and improving performance over time. It includes various types of maintenance such as corrective, adaptive, perfective, and preventive maintenance.\n\nThese four activities together form the software life cycle, ensuring that the product is useful, reliable, and adaptable."
    },
    {
      "id": 60,
      "module": "MODULE-4",
      "topic": "Software Design",
      "question": "What do you understand about software design and implementation?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Software design and implementation is a stage in the software engineering process where an executable software system is developed, and these activities are invariably interleaved. Software design is a creative activity in which you identify software components and their relationships, based on a customer's requirements. Implementation is the process of realizing the design as a program.\n\nKey aspects to understand about Software Design and Implementation:\n\n1.  **Build or Buy:**  It is now possible to buy off-the-shelf systems (COTS) that can be adapted and tailored to the users' requirements. The design process then becomes concerned with how to use the configuration features of that system to deliver the system requirements.\n2.  **Object-Oriented Design Process:** Object-oriented design processes involve developing different system models. Design models are an important communication mechanism for large systems developed by different groups.\n3.  **Process Stages:**\n *   Define the context and modes of use of the system.\n *   Design the system architecture.\n *   Identify the principal system objects.\n *   Develop design models.\n *   Specify object interfaces.\n4.  **System Context and Interactions:** Understanding the relationships between the software being designed and its external environment is essential. Understanding the context helps establish the boundaries of the system.\n5.  **Architectural Design:**  Identify the major components that make up the system and their interactions, organizing the components using an architectural pattern.\n6.  **Object Class Identification:** Object class identification in the weather station system may be based on the tangible hardware and data in the system such as Ground thermometer, Anemometer, Barometer weather station etc.\n7.  **Design Models:**\n *   Subsystem models: Shows how the design is organized into logically related groups of objects.\n *   Sequence models: Show the sequence of object interactions.\n *   State machine models: Show how individual objects change their state in response to events.\n8.  **Interface Specification:** Object interfaces have to be specified so that the objects and other components can be designed in parallel. Objects may have several interfaces which are viewpoints on the methods provided.\n9.  **Design Patterns:** A design pattern is a way of reusing abstract knowledge about a problem and its solution. A pattern is a description of the problem and the essence of its solution.\n10. **Implementation Issues:** Focus is not on programming, but on other implementation issues such as Reuse, Configuration management, and Host-target development."
    },
    {
      "id": 61,
      "module": "MODULE-2",
      "topic": "Software Process activities, Agile software Development and Requirements Analysis (8 hours) Process activities",
      "question": "Explain the process improvement cycle and activities with the help of a diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The process improvement cycle, as described in the notes regarding software evolution and project management, involves several activities aimed at continuously improving the software development process. Since a specific diagram illustrating the process improvement cycle isn't directly presented, a conceptual explanation is provided. The core idea is to identify areas for improvement, implement changes, assess their impact, and refine the process iteratively.\n\n1.  **Identify Improvement Areas:** This involves analyzing the current software development process to pinpoint bottlenecks, inefficiencies, or areas where errors frequently occur. Methods for identification can include process analysis, defect analysis, and feedback from the development team.\n2.  **Define Goals and Metrics:** Establish clear, measurable goals for the improvement effort. Define specific metrics to track progress and determine whether the changes are effective. Examples include reducing defect density, improving development speed, or increasing customer satisfaction.\n3.  **Plan Changes:** Develop a detailed plan outlining the steps required to implement the changes. This plan should include timelines, resource allocation, and responsibilities.\n4.  **Implement Changes:** Execute the planned changes to the software development process. This may involve adopting new tools, modifying existing processes, or providing training to the development team.\n5.  **Monitor and Measure:** Continuously monitor the key metrics defined earlier to assess the impact of the changes. Collect data to determine whether the changes are achieving the desired results.\n6.  **Analyze Results:** Analyze the collected data to identify trends, patterns, and areas for further improvement. This analysis should provide insights into what is working well and what needs further adjustment.\n7.  **Refine and Repeat:** Based on the analysis, refine the changes or identify new areas for improvement. Repeat the cycle by planning, implementing, monitoring, and analyzing the refined changes. The core idea is the refinement is iterative and incremental.\n8.  **Documentation:** Throughout the process, document all activities, including identified improvement areas, goals, metrics, plans, implementation steps, monitoring data, analysis results, and refinements. This documentation will serve as a valuable resource for future improvement efforts.\n9.  **Communication:** Maintain open communication with all stakeholders throughout the process. Share progress updates, solicit feedback, and address any concerns or questions. This can be the project managers. \n10. **Feedback Loops:** Establish feedback loops within the process to ensure continuous learning and adaptation. Encourage the development team to provide feedback on the changes and incorporate this feedback into future iterations."
    },
    {
      "id": 62,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "Explain the testing phases in a plan-driven software process (V-model) with a neat diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The plan-driven software process, specifically the V-model, outlines distinct phases for both development and testing. The V-model emphasizes the relationship between each development stage and its corresponding testing stage. Here's an explanation of the testing phases in the V-model, along with how the diagram should look:\n\n1.  **Requirements Phase & Customer Test Plan (Acceptance Testing):**\n    *   In this initial stage, all the possible requirements of the system are gathered and documented. This stage focuses on what the customer expects from the software. The corresponding testing phase is acceptance testing/customer testing. It validates the entire system against the original requirements and ensures the final product meets customer expectations. Real users test the system with real data to find missing or unclear requirements.\n2.  **System Specification & System Integration Test Plan (System Testing):**\n    *   The System Specification phase translates customer needs into detailed system-level requirements. This involves defining the system's scope and overall functionality. The corresponding System Integration Testing phase ensures that the entire software meets requirements and works correctly. System testing during development involves integrating components to create a version of the system and then testing the integrated system. The focus is testing the interactions between components to verify compatibility, correct interaction, and accurate data transfer.\n3.  **System Design & Sub-system Integration Test Plan (Integration Testing):**\n    *   In the System Design phase, the architecture of the system is designed, detailing how components will interact. The corresponding testing phase, Sub-system Integration Testing, validates that smaller subsystems interact correctly. Testing policies may be developed to define the required system test coverage. These include testing all system functions accessed through menus, combinations of functions accessed through the same menu, and all functions with both correct and incorrect user input.\n4.  **Component Design & Component Code and Test (Unit Testing):**\n    *   This phase involves designing individual modules or components that will be coded. The corresponding testing phase is Component Testing (Unit Testing). Each part is tested alone by developers using tools. Objectives are to detect faults due to interface errors or invalid assumptions about interfaces. Interface types include parameter interfaces, shared memory interfaces, procedural interfaces, and message-passing interfaces. Interface errors may be due to misuse, misunderstanding, or timing issues.\n5.  **Coding:** Developers write the actual code based on design documents.\n\n**Diagram Description (Refer notes for diagram):**\nThe V-model diagram visually represents these phases in a V-shape. The left side of the \"V\" represents the sequential phases of the development lifecycle (Requirements, System Design, Architectural Design, and Module Design). The right side of the \"V\" mirrors these phases with the corresponding testing phases (Acceptance Testing, System Testing, Integration Testing, and Unit Testing). The diagram emphasizes the association of each development stage with a matching testing stage, reinforcing that testing is planned from the beginning, not as an afterthought."
    },
    {
      "id": 63,
      "module": "MODULE-5",
      "topic": "Software evolution",
      "question": "Explain the system evolution process with a diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Software evolution is the process of developing software over time to adapt to changing requirements, fix issues, and improve performance. It is a continuous, evolving process, not a separate phase like development and maintenance used to be viewed. The process is as follows:\n\n1.  **Define System Requirements**: Identify what the system needs to do by gathering information about user needs, business goals, and technical requirements.\n2.  **Assess Existing Systems**: Review the current system(s) in place to find out what works well and what needs improvement.\n3.  **Propose System Changes**: Suggest ways to improve or upgrade the system. These changes should fix issues or add new features based on requirements.\n4.  **Modify Systems**: Implement the proposed changes. This can include updating the existing system or creating a new one.\n5.  **Existing Systems & New System**: Existing systems feed into the assessment stage for evaluation. The new system is created or updated after modifications and may later become the \"existing system\" for future improvements.\n\n**Diagram Description**: The diagram should illustrate a cycle. It starts with \"Define System Requirements,\" which leads to \"Assess Existing Systems.\" This assessment results in \"Propose System Changes,\" which are then implemented in the \"Modify Systems\" stage, and loop backs to step 2 to continuously improve the software. Existing systems provide input to the assessment stage, while the new system results from modifications and can be reassessed in the future for further improvements."
    },
    {
      "id": 64,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "List the three stages of testing.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The three stages in the testing process, as per the notes, are:\n\n1.  **Component Testing:** Each individual part of the software is tested in isolation by developers. Tools like JUnit are used.\n2.  **System Testing:** All the components are integrated and tested together to identify issues related to their interaction and to ensure that the system meets its requirements.\n3.  **Customer Testing:** Real users test the system using real-world data to uncover any missing or unclear requirements."
    },
    {
      "id": 65,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "What are the principles of agile methods?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the notes, the principles of agile methods, as derived from the Agile Manifesto, include:\n\n1.  **Individuals and interactions over processes and tools:** Agile values direct communication and collaboration among team members more than strict adherence to predefined processes and tools. The emphasis is on leveraging the collective intelligence and adaptability of the team.\n2.  **Working software over comprehensive documentation:** Agile prioritizes delivering functional software increments over creating extensive documentation. While documentation is still important, the focus is on producing code that meets user needs and provides tangible value.\n3.  **Customer collaboration over contract negotiation:** Agile emphasizes continuous engagement and collaboration with the customer throughout the development lifecycle. The goal is to build a product that aligns with the customer's evolving needs and expectations.\n4.  **Responding to change over following a plan:** Agile embraces change and adapts to evolving requirements and market conditions. The approach is to be flexible and responsive rather than rigidly adhering to a predetermined plan.\n5.  **Flexibility:** Agile methods adapt to changing customer needs, market demands, or technology. Plans are not rigid, and changes can be incorporated at any stage.\n6.  **Customer Focus:** The product is built around user needs and expectations, with regular demos and review meetings with stakeholders.\n7.  **Incremental Delivery:** Software is delivered in small increments, enabling early use and feedback, starting with essential features and adding more over time.\n8.  **Collaboration:** Teamwork is emphasized between developers, testers, business analysts, and customers through daily stand-ups and cross-functional sprint planning sessions.\n9.  **Continuous Improvement:** Teams reflect on past work to identify what can be improved and implement those improvements in subsequent iterations through retrospective meetings at the end of each sprint.\n10. **Simplicity:** Agile builds only what is necessary to meet user needs, starting with a simple, functional interface before adding complexity.\n11. **Technical Excellence:** Clean code, good design, and testing are promoted for maintainable and scalable software with regular code reviews and coding standards.\n12. **Sustainable Pace:** Workload is planned to avoid burnout and maintain steady productivity, setting realistic sprint goals and avoiding overtime."
    },
    {
      "id": 66,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "Explain the extreme programming release cycle with the help of a diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The extreme programming (XP) release cycle, as illustrated in Figure 3.3 (refer to notes for diagram), demonstrates how features are selected, developed, and delivered in small increments. Here's a breakdown of the cycle:\n\n1.  **Select User Stories for This Release:** User stories, which are short descriptions of features, are chosen based on customer priorities and business value. These stories define the functionality to be included in the upcoming release.\n\n2.  **Break Down Stories to Tasks:** Each user story is divided into smaller, more manageable development tasks. These tasks represent the units of work for developers to implement.\n\n3.  **Plan Release:** A release plan is created, outlining which stories will be delivered and when. Effort estimation and resource planning are conducted at this stage.\n\n4.  **Develop / Integrate / Test Software:** Development teams write code, integrate components, and perform continuous testing. Practices like pair programming and test-first development (TDD) are employed to maintain quality.\n\n5.  **Release Software:** Once tested, the increment is delivered to the customer, who can immediately start using the new features.\n\n6.  **Evaluate System:** Feedback is gathered from users and stakeholders, including assessments of performance, usability, and feature improvements. These insights are used to plan the next iteration.\n\nThe cycle continues with new user stories for the next release, ensuring frequent delivery and continuous improvement. Extreme Programming (XP) focuses on:\n*   Frequent small releases with simple user stories.\n*   Continuous customer involvement.\n*   Pair programming and shared code ownership.\n*   Test-first coding and regular refactoring.\n*   Keeping designs simple and adaptable."
    },
    {
      "id": 67,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "List and explain five extreme programming practices.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Extreme Programming (XP) is an agile software development methodology that emphasizes frequent releases and close collaboration. Here are five key practices:\n\n1.  **Frequent Releases:** XP promotes delivering small, functional increments of software to the customer frequently. This allows for early feedback and adaptation to changing requirements.\n\n2.  **Pair Programming:** Two developers work together at one workstation. One writes code while the other reviews it. This is meant to improve code quality through real-time peer review and shared code ownership.\n\n3.  **Test-First Development (TDD):** In XP, tests are written before the code. This ensures correctness, clarifies requirements, and promotes maintainability. \n\n4.  **User Stories:** Requirements are captured as short, simple descriptions of desired functionality from the user's perspective. This helps maintain a user-centric focus throughout development.\n\n5.  **Continuous Integration:** Code is integrated and tested daily to detect and resolve issues early, ensuring a stable and working codebase."
    },
    {
      "id": 68,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "Explain: i. Refactoring ii. User stories iii. Test driven development",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the provided notes, here is an explanation of the requested topics:\n\n**i. Refactoring:**\n\n*   XP (Extreme Programming) avoids planning for future changes and instead uses continuous refactoring. (module2.pdf, page 19)\n*   Refactoring is about constantly improving code to keep it clean and flexible. (module2.pdf, page 19)\n*   It keeps code clean, simple, and easier to change later. (module2.pdf, page 19)\n*   Examples of refactoring include removing duplicate code, renaming methods, and reorganizing classes. (module2.pdf, page 19)\n*   Pair programming encourages refactoring (module2.pdf, page 22).\n\n**ii. User Stories:**\n\n*   Agile uses user stories to capture changing requirements as simple, user-focused scenarios. (module2.pdf, page 18)\n*   Customers help create, prioritize, and refine these stories. (module2.pdf, page 18)\n*   Stories guide short development cycles with regular releases. (module2.pdf, page 18)\n*   User Stories are chosen based on customer priorities and business value. These stories define what functionality will be included in the upcoming release. (module2.pdf, page 14)\n*   Each user story is divided into smaller development tasks. These tasks are manageable units of work for developers to implement. (module2.pdf, page 14)\n*   Extreme Programming (XP) focuses on frequent small releases with simple user stories. (module2.pdf, page 15)\n*   Stories are easy to relate to and help gather input from a broader audience. (module4.pdf, page 81)\n* Sharing stories (e.g., via a wiki) encourages feedback from users like teachers and students. (module4.pdf, page 81)\n\n**iii. Test Driven Development:**\n\n*   Test-first development (TDD) means tests are written before the code to ensure correctness and maintainability. (module2.pdf, page 12)\n*   Tests are based on user stories and tasks. (module2.pdf, page 20)\n*   Test-first coding is a part of regular refactoring. (module2.pdf, page 15)\n*   Component testing is usually done by programmers during development. (module3.pdf, page 45)\n* In test-driven development  (agile), tests are written before coding to clarify requirements and avoid delays. (module3.pdf, page 45)\n* Writing test cases should be used as part of the validation process (module4.pdf, page 97)\n\nBenefits of Test-First Development:\n*   Catches problems early. (module2.pdf, page 21)\n*   Reduces misunderstandings. (module2.pdf, page 21)\n*   Avoids \"test-lag\". (module2.pdf, page 21)\n*   Tests run quickly and often. (module2.pdf, page 21)\n"
    },
    {
      "id": 69,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "What are the phases of Scrum? Also, list some of the benefits of Scrum.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The Scrum sprint cycle includes the following phases:\n\n1.  **Review Work to Be Done:** The team and Product Owner review all pending features, enhancements, and bug fixes. These items are stored in the Product Backlog (a prioritized list of work).\n2.  **Select Items & Plan Sprint:** The team selects high-priority items from the product backlog to be completed in the next sprint. A Sprint Backlog is created, detailing tasks to be done during the sprint. Sprint planning ensures the scope is realistic and achievable.\n3.  **Sprint (Development Phase):** The team works on implementing the selected backlog items. Daily Scrum meetings (15-minute stand-ups) track progress and address blockers. At the end of the sprint, the result is a Potentially Shippable Software Increment.\n4.  **Review Sprint:** The team demonstrates the completed work to stakeholders for feedback. Adjustments are made to priorities for the next sprint if needed.\n5.  **Cycle Repeats:** Feedback and new requirements are incorporated. The next sprint begins, ensuring continuous delivery and improvement.\n\nBenefits of Scrum:\n\n*   Work is broken into manageable parts.\n*   Handles changing requirements well.\n*   Clear progress and better teamwork\n*   Enables on-time delivery and early feedback.\n*   Builds trust between customers and developers."
    },
    {
      "id": 70,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "Where are agile methods used and why?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Agile methods are used in two main types of system development:\n\n1.  **Product development:** They are used for developing new products where requirements evolve based on market trends and customer feedback. For example, building a new mobile app where features are added and improved through user feedback.\n\n2.  **Custom system development:** They are applied when creating tailored solutions for specific clients or organizations with unique needs. For example, developing a custom CRM (Customer Relationship Management) system for a company with specialized workflows.\n\nAgile methods are favored in these scenarios because they offer flexibility, adaptability, and customer collaboration, allowing for quick responses to changing requirements and continuous delivery of value."
    },
    {
      "id": 71,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "Explain the scrum sprint cycle with the help of a diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The scrum sprint cycle organizes work into fixed-length iterations, typically 2-4 weeks. Here's how it works:\n\n1.  **Review Work to Be Done:** The team and Product Owner examine all pending features, enhancements, and bug fixes. These items reside in the **Product Backlog**, which is a prioritized list of work.\n\n2.  **Select Items & Plan Sprint:** The team picks high-priority items from the product backlog to be completed in the upcoming sprint. This selection results in the creation of a **Sprint Backlog**, which details the specific tasks to be done during the sprint. Sprint planning ensures the scope of work is realistic and achievable within the sprint timeframe.\n\n3.  **Sprint (Development Phase):** The team implements the items selected from the sprint backlog. **Daily Scrum meetings** (brief, 15-minute stand-ups) are held to track progress and address any impediments or blockers. The result of this development phase is a **Potentially Shippable Software Increment**, which represents working software.\n\n4.  **Review Sprint:** At the end of the sprint, the team demonstrates the completed work to stakeholders to gather feedback. This review allows for adjustments to be made to priorities for the next sprint, if necessary.\n\n5.  **Cycle Repeats:** The feedback and new requirements that emerge are incorporated into the product backlog. The next sprint then begins, thereby ensuring continuous delivery and improvement.\n\n\\*\\*Key Outputs:\\*\\*\n\n*   **Product Backlog:** It is the master list that contains all the desired features.\n\n*   **Sprint Backlog:** A subset of items from the product backlog that have been chosen for implementation and tasks for the current sprint.\n\n*   **Potentially Shippable Software:** Represent the shippable working increment which is ready for release."
    },
    {
      "id": 72,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "List and explain five agile principles in organisational practice.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the provided notes, here are five agile principles explained in the context of organizational practice:\n\n1.  **Individuals and interactions over processes and tools:** Agile emphasizes direct communication and collaboration among team members rather than strict adherence to predefined processes and tools. This fosters a more flexible and responsive environment where teams can quickly adapt to changing requirements and solve problems efficiently.\n\n2.  **Working software over comprehensive documentation:** Agile prioritizes delivering functional software in short iterations over producing extensive documentation. While documentation is still important, the focus is on creating a working product that meets user needs, with documentation serving to support that goal.\n\n3.  **Customer collaboration over contract negotiation:** Agile promotes close collaboration between the development team and the customer throughout the project lifecycle. This continuous feedback loop ensures that the software being developed aligns with the customer's evolving needs and expectations. It replaces rigid contract negotiations with ongoing dialogue and shared decision-making.\n\n4.  **Responding to change over following a plan:** Agile recognizes that change is inevitable in software development. Instead of rigidly adhering to a fixed plan, agile methodologies embrace change and allow teams to adapt to new requirements and priorities as they emerge. This adaptability is crucial for delivering successful software in dynamic and uncertain environments.\n\n5.  **Flexibility:** Agile organizations are able to adapt to changing customer needs, market demands, or technology. The plans are not rigid; changes can be incorporated at any stage. Example: Adding a new feature based on customer feedback mid-project.\n"
    },
    {
      "id": 73,
      "module": "MODULE-2",
      "topic": "Requirement Validation",
      "question": "Explain what is meant by test automation.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Test automation is not explicitly defined in the provided notes. However, based on the context, testing is a crucial part of software development, particularly in the validation stage. Module 4 describes testing as intended to show that a program does what it is intended to do and to discover program defects before it is put into use. \n\nGiven the context, test automation would logically involve using tools to automatically execute tests and compare the results with the expected outcomes. This would improve efficiency and catch problems early in the software development lifecycle. Benefits: Catches problems early, Reduces misunderstandings, Avoids \"test-lag\", Tests run quickly and often."
    },
    {
      "id": 74,
      "module": "MODULE-2",
      "topic": "Requirements engineering Process, Requirement elicitation, Requirement specification, Requirement Validation and management Applications",
      "question": "Explain what is meant by user stories for software requirements.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "User stories are used in Agile to capture changing requirements as simple, user-focused scenarios. Customers help create, prioritize, and refine these stories. Stories guide short development cycles with regular releases. They are high-level, narrative descriptions of how the system might be used. Stories are easy to relate to and help gather input from a broader audience."
    },
    {
      "id": 75,
      "module": "MODULE-1",
      "topic": "Introduction",
      "question": "Give a simple example.",
      "marks": 2,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "An ATM machine is a simple example where a user inserts an ATM card, enters the correct PIN, selects \"Withdraw Cash\" option, enters the amount (e.g., ₹500), and if the balance is sufficient, cash is dispensed, a receipt is printed, and the balance is updated."
    },
    {
      "id": 76,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "Explain refactoring with the help of examples.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Refactoring involves improving the internal structure of code without changing its external behavior. It aims to enhance code readability, reduce complexity, and improve maintainability. Extreme Programming (XP) emphasizes continuous refactoring to keep code clean, simple, and adaptable. \n\nExamples include:\n\n1.  **Removing duplicate code**: Identifying and eliminating redundant code blocks by creating a common function or module.\n2.  **Renaming methods**: Changing method names to be more descriptive and reflect their purpose clearly.\n3.  **Reorganizing classes**: Restructuring classes to improve organization and relationships between them.\n\nRefactoring helps in maintaining code quality and makes future modifications easier."
    },
    {
      "id": 77,
      "module": "MODULE-2",
      "topic": "Agile Software development",
      "question": "Outline the role of a scrum master in scrum.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The Scrum Master plays a critical role in ensuring a Scrum team adheres to Agile principles and Scrum practices. They serve as a facilitator, coach, and servant-leader for the development team, Product Owner, and the broader organization.\n\nThe roles include:\n\n1.  **Guiding the team:** The Scrum Master ensures the team understands and applies Scrum values and practices.\n2.  **Reporting progress:**  They help in reporting the team's progress and removing impediments.\n3.  **Handling logistics:** This includes facilitating Scrum events and ensuring the team has what it needs to be successful. \n4.  **Servant-leader:** A Scrum Master is a key role in the Scrum framework responsible for ensuring that the team follows Agile principles and Scrum practices effectively."
    },
    {
      "id": 78,
      "module": "MODULE-3",
      "topic": "System models",
      "question": "Explain the difference between a context model and a use case model.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "A context model illustrates the operational context of a system, showing what lies outside the system boundaries and its relationship with other systems. It provides an external perspective. \n\nA use case model represents discrete tasks that involve external interaction with a system. Use cases are developed to support requirements elicitation. They are represented diagrammatically and in a detailed textual form, showing the interactions between a system and its environment, from an interaction perspective."
    },
    {
      "id": 79,
      "module": "MODULE-3",
      "topic": "System models",
      "question": "How do system models complement each other?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "System models complement each other by providing different views or perspectives of the same system. These perspectives include:\n\n1.  **External perspective:** Models the context or environment of the system.\n2.  **Interaction perspective:** Models the interactions between a system and its environment, or between the components of a system.\n3.  **Structural perspective:** Models the organization of a system or the structure of the data that is processed by the system.\n4.  **Behavioral perspective:** Models the dynamic behavior of the system and how it responds to events.\n\nDifferent UML diagram types support these perspectives such as activity diagrams, use case diagrams, sequence diagrams, class diagrams and state diagrams. Each model serves a purpose of facilitating discussion, documenting the system or detailed description to generate a system implementation, all which provides necessary understanding to stakeholders."
    },
    {
      "id": 80,
      "module": "MODULE-3",
      "topic": "Aggregation",
      "question": "What are aggregation and generalization?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the notes provided, here is the information regarding aggregation and generalization:\n\n**Generalization:**\nGeneralization is a technique used to manage complexity by placing entities into more general classes and learning the characteristics of these classes. In modeling systems, it's useful to examine classes to see if there is scope for generalization, so you don't have to look at all classes in the system to see if they are affected by a change. In object-oriented languages like Java, generalization is implemented using class inheritance mechanisms. Attributes and operations associated with higher-level classes are also associated with lower-level classes, which inherit attributes and operations from their superclasses and add more specific attributes and operations. Refer notes for generalization hierarchy diagram.\n\n**Aggregation:**\nAn aggregation model shows how classes that are collections are composed of other classes. Aggregation models are similar to the part-of relationship in semantic data models. Refer notes for the aggregation association diagram."
    },
    {
      "id": 81,
      "module": "MODULE-3",
      "topic": "System models",
      "question": "What is system modeling?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "System modeling is the process of developing abstract models of a system, where each model presents a different view or perspective of that system. System modeling helps the analyst to understand the functionality of the system, and these models are used to communicate with customers. It often involves representing a system using graphical notation, commonly based on the Unified Modeling Language (UML). UML diagram types include activity diagrams (show activities involved in a process or data processing), use case diagrams (show the interactions between a system and its environment), sequence diagrams (show interactions between actors and the system and between system components), class diagrams (show object classes in the system and the associations between these classes), and state diagrams (show how the system reacts to internal and external events). System perspectives include external (modeling the context or environment of the system), interaction (modeling the interactions between a system and its environment or components), structural (modeling the organization or data structure), and behavioral (modeling dynamic behavior and responses to events)."
    },
    {
      "id": 82,
      "module": "MODULE-3",
      "topic": "class diagram, generalization, Aggregation",
      "question": "Discuss the use of class diagrams.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Class diagrams are used when developing an object-oriented system model to show the classes in a system and the associations between these classes. An object class can be thought of as a general definition of one kind of system object. An association is a link between classes that indicates that there is some relationship between these classes.\n\nKey points regarding the use of class diagrams:\n\n1.  **Object Class Definition:** An object class is a general definition of one kind of system object.\n\n2.  **Associations:** An association is a link between classes, indicating a relationship between them.\n\n3.  **Early Stages of Development:** During the early stages of the software engineering process, objects represent real-world entities such as a patient, a prescription, doctor, etc.\n\n4.  **UML Notation:**\n    *   Shows the relationship between Patient and Patient Record\n    *   This shows 1 to 1 relationship between the two, each patient has one record, and there is only one patient for each patient record.\n\n5.  **Multiplicity:**\n    *   The ‘*’ is used to represent many.\n    *   The diagram shows a one-to-many relationship between Patient and Consultation, i.e., many patients can have many consultations, and many consultations can have many patients.\n\n6.  **Class Attributes and Operations:**\n    *   UML diagram for class Consultation includes the name of the object class.\n    *   Class attributes include names (required and optional) and types.\n    *   Operations or methods are also included.\n\n7.  **Generalization:** Examines classes in a system to see if there is scope for generalization. If changes are proposed, then you do not have to look at all classes in the system to see if they are affected by the change.\n\n8.  **Implementation in Java:** In object-oriented languages, such as Java, generalization is implemented using the class inheritance mechanisms built into the language.\n\n9.  **Inheritance:** Attributes and operations associated with higher-level classes are also associated with the lower-level classes. The lower-level classes or subclasses inherit the attributes and operations from their superclasses. These lower-level classes then add more specific attributes and operations.\n\n10. **Aggregation Models:** An aggregation model shows how classes that are collections are composed of other classes. Aggregation models are similar to the part-of relationship in semantic data models."
    },
    {
      "id": 83,
      "module": "MODULE-3",
      "topic": "UML diagram types",
      "question": "What are UML Diagrams?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "UML diagrams are graphical notations used to represent a system. System modeling helps analysts understand the system's functionality, and these models are used to communicate with customers. UML diagrams are now almost always based on the Unified Modeling Language (UML). \n\nThere are various types of UML diagrams including:\n*   Activity diagrams: show the activities involved in a process or in data processing.\n*   Use case diagrams: show the interactions between a system and its environment.\n*   Sequence diagrams: show interactions between actors and the system and between system components.\n*   Class diagrams: show the object classes in the system and the associations between these classes.\n*   State diagrams: show how the system reacts to internal and external events."
    },
    {
      "id": 84,
      "module": "MODULE-3",
      "topic": "Use case diagrams, which show the interactions between \na system and its environment.",
      "question": "What are the main components in a use case?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Use case modeling involves a discrete task that has external interaction with a system. The actors can be people or other systems. Each use case is represented diagrammatically and also in a detailed textual form. Refer notes for Use case diagram. \n\nComponents of use case:\n1.  Actors (users or other systems): Shown as stick figures.\n2.  Use cases (interactions): Shown as ellipses.\n3.  Lines: Connect actors to use cases; arrows can show who initiates the interaction."
    },
    {
      "id": 85,
      "module": "MODULE-3",
      "topic": "Event driven modeling, Model driven engineering Applications",
      "question": "Compare state diagrams and activity diagrams.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "State diagrams and activity diagrams are both UML diagram types used in system modeling, but they serve different purposes. Here's a comparison:\n\n1.  **Purpose**: State diagrams model the behavior of a single object in response to events, while activity diagrams model the flow of activities in a process or data processing.\n2.  **Focus**: State diagrams focus on the different states an object can be in and the transitions between those states. Activity diagrams focus on the sequence of actions or activities that occur.\n3.  **Elements**: State diagrams use states (nodes) and transitions (arcs) triggered by events. Activity diagrams use activity states, actions, decisions, forks, joins, and swimlanes.\n4.  **Event-Driven vs. Data-Driven**: State diagrams are commonly used for event-driven systems, showing how a system responds to external and internal events. Activity diagrams are often used for data-driven systems, showing the sequence of actions involved in processing input data.\n5.  **Dynamic Behavior**: Both are behavioral models, representing dynamic behavior, but state diagrams emphasize the object's lifecycle, while activity diagrams emphasize process flow.\n6.  **Real-time Systems**: State diagrams are often used for modeling real-time systems due to their ability to show system responses to stimuli.\n7.  **Business Systems**: Activity diagrams are useful for modeling business processes, showing end-to-end processing.\n8.  **UML Integration**: Both are integral parts of UML.\n9. **Nodes and Arcs**: State diagrams show system states as nodes and events as arcs between these nodes. Activity diagrams use activity states and transitions to illustrate the flow.\n10. **Transitions**: In state diagrams, when an event occurs, the system moves from one state to another. In activity diagrams, transitions represent the completion of an activity and the movement to the next activity based on conditions or control flows.\n11. **Abstraction**: Both diagram types provide abstractions of system behavior but at different levels. State diagrams abstract the lifecycle of an object, while activity diagrams abstract a process or workflow.\n12. **Use Case**: State diagrams model how a system reacts to internal and external events. Activity diagrams show the activities involved in a process or in data processing.\n13. **Model-Driven Engineering**: These diagrams are used in model-driven engineering to visualize the system, support discussions, document systems and generate system implementations.\n14. **Stimuli**: Both models respond to Stimuli, Data and Events.\n15. **Stakeholders**: Both diagram types can clarify functionality for stakeholders."
    },
    {
      "id": 86,
      "module": "MODULE-3",
      "topic": "sequence diagram",
      "question": "What are the key elements of a sequence diagram, and how do they contribute to understanding system behavior?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The key elements of a sequence diagram, based on the provided notes, are:\n\n1.  **Actors and Objects:** These are the entities that interact within the system. They are listed along the top of the diagram with a dotted line drawn vertically from them.\n2.  **Lifelines:** Dotted lines extending vertically from actors and objects, representing the passage of time.\n3.  **Messages/Interactions:** Annotated arrows between lifelines indicate interactions between objects/actors, showing the direction and type of communication.\n4.  **Sequence of Interactions:** The diagram illustrates the sequence of interactions that take place during a particular use case or use case instance, read from top to bottom.\n5.  **Activation Boxes:** A thin rectangle in an object's lifeline signifies the period when the object is the controlling object in the system.\n\nHow they contribute to understanding system behavior:\n\n*   **Visualization of Interactions:** Sequence diagrams provide a visual representation of how actors and objects interact, making it easier to understand the flow of messages and the dependencies between them.\n*   **Modeling Use Cases:** These diagrams model the interactions between actors and the objects within a system. A sequence diagram shows the sequence of interactions that take place during a particular use case or use case instance.\n*   **Temporal Ordering:** By showing the order in which messages are exchanged, sequence diagrams clarify the timing and dependencies between different parts of the system.\n*   **System Component Interaction:** Sequence diagrams facilitate an understanding of component interactions, thereby clarifying how a proposed system structure is likely to deliver the required system performance and dependability.\n*   **Communication Problems:** They highlight communication problems that may arise between systems.\n*   **Troubleshooting:** By visualizing the interactions, it becomes easier to identify potential bottlenecks, inefficiencies, or errors in the system's design.\n*   **System Design:** They describe external behavior and operational constraints and they can be used in system design.\n*   **Example**: In the Mentcare system (MHC-PMS), the sequence diagram shows the receptionist triggering the `ViewInfo` method in an instance `P` of the `PatientInfo` object class by supplying the patient's identifier, `PID`. `P` then calls the database to return the required information, supplying the receptionist's identifier to allow security checking."
    },
    {
      "id": 87,
      "module": "MODULE-3",
      "topic": "class diagram, generalization, Aggregation",
      "question": "Explain class diagram with a neat diagram. How effective is it in system modeling?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "A class diagram is a structural model used in object-oriented system modeling to display the organization of a system in terms of its classes and the relationships between those classes. Refer notes for diagram. \n\nKey aspects of class diagrams:\n\n1.  **Classes:** Represented as rectangles, each class encapsulates data (attributes) and behavior (operations/methods). These classes represent general definitions of one kind of system object. Attributes show name, required and optional to include types. Operations or methods are actions that the class can perform. \n\n2.  **Associations:**  Links between classes indicate relationships, depicted as lines connecting classes. Associations define how classes are related to each other.  Multiplicity is indicated using notation such as 1 or *. For example, a one-to-many relationship between Patient and Consultation means one patient can have many consultations.\n\n3.  **Generalization:** This is a technique used to manage complexity. The classes in a system are analyzed to see if there is scope for generalization. Rather than learn the detailed characteristics of every entity that is experienced, these entities are placed in more general classes. In a generalization, the attributes and operations associated with higher-level classes are also associated with the lower-level classes. The lower-level classes or subclasses inherit the attributes and operations from their superclasses and then add more specific attributes and operations.\n\n4.  **Aggregation:** An aggregation model shows how classes that are collections are composed of other classes. These models are similar to the part-of relationship in semantic data models.\n\nEffectiveness in System Modeling:\n\n1.  **Communication:** Class diagrams facilitate discussions about existing or proposed systems by providing a graphical notation that is based on the Unified Modeling Language (UML).\n\n2.  **Documentation:** They serve as accurate representations of the system structure, which can be used to document an existing system.\n\n3.  **Design Description:** Class diagrams aid in discussing and designing the system architecture by displaying the organization of a system in terms of components and their relationships."
    },
    {
      "id": 88,
      "module": "MODULE-3",
      "topic": "Use case diagrams, which show the interactions between \n a system and its environment.",
      "question": "What are Use case diagrams? Explain with an example.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Use case diagrams show the interactions between a system and its environment. They were originally developed to support requirements elicitation and are now incorporated into the UML. Each use case represents a discrete task that involves external interaction with a system. Actors in a use case may be people or other systems. These diagrams provide an overview of the use case and can be represented diagrammatically and in a more detailed textual form.\n\nFor example, the 'Transfer data' use case shows how a medical receptionist initiates a transaction and data is transferred to the patient record system. In a use case diagram, actors (users or other systems) are shown as stick figures, and use cases (interactions) are shown as ellipses. Lines connect actors to use cases; arrows can show who initiates the interaction.\n\nHere is a more detailed explanation:\n1.  **Purpose**: Use case diagrams are used for modelling system interactions and can be helpful in system design.\n2.  **Actors**: Actors represent users or external systems that interact with the system.\n3.  **Use Cases**: Use cases represent the tasks or interactions that actors have with the system.\n4.  **Diagrammatic Representation**: The diagrams provide an overview of use cases.\n5.  **Textual Form**: Use cases are also described in more detailed textual form to provide additional information.\n6.  **Medical Receptionist Example**: The medical receptionist initiates the transaction and transfers data to the patient record system.\n7.  **UML Integration**: Use case diagrams are part of the Unified Modeling Language (UML).\n8.  **Requirements Elicitation**: These diagrams support requirements elicitation, capturing how users interact with the system to complete tasks."
    },
    {
      "id": 89,
      "module": "MODULE-3",
      "topic": "Model driven engineering Applications",
      "question": "Explain the concept of Model Driven Engineering. What are its benefits and challenges?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Model-Driven Engineering (MDE) is a software development approach where models, instead of programs, become the primary outputs of the development process. Code is then automatically generated from these models.\n\n**Benefits of MDE:**\n\n1.  **Higher Level of Abstraction:** MDE allows systems to be considered at higher levels of abstraction, freeing engineers from programming language details and platform specifics.\n2.  **Platform Adaptability:** Automatic code generation makes it cheaper to adapt systems to new platforms.\n\n**Challenges of MDE:**\n\n1.  **Cost of Translator Development:** Savings from automatic code generation might be offset by the costs of developing translators for new platforms.\n2.  **Abstraction vs. Implementation:** Models created for abstraction may not be suitable for direct implementation.\n\nIn MDE, different types of models are created:\n\n*   **Computation Independent Model (CIM):** Models the important domain abstractions.\n*   **Platform Independent Model (PIM):** Models the system's operation without specific implementation details using UML models to show static structure and response to events.\n*   **Platform Specific Models (PSM):** Transformations of the PIM for each application platform, adding platform-specific details.\n\nWhile MDA (Model-Driven Architecture) developers claim it supports an iterative approach suitable for agile methods, the extensive upfront modeling contradicts fundamental agile principles. However, if transformations can be fully automated and a complete program generated from a PIM, MDA could potentially be used in an agile development process."
    },
    {
      "id": 90,
      "module": "MODULE-3",
      "topic": "System models",
      "question": "Explain the difference between a system model and a context model.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "A context model illustrates the operational context of a system, showing what lies outside the system boundaries. It defines the system's relationship with other systems and highlights the external environment. In contrast, a system model represents the system using graphical notations, offering different views or perspectives of the system itself. System models help analysts understand the system's functionality and communicate with customers. While context models focus on the system's environment and external systems, system models focus on the system's internal structure and behavior."
    },
    {
      "id": 91,
      "module": "MODULE-3",
      "topic": "Event driven modeling, Model driven engineering Applications",
      "question": "What is event-driven modeling, and why is it used in certain types of systems?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Event-driven modeling is a way of representing real-time systems by showing how the system responds to external and internal events. It's based on the idea that a system has a limited number of states and that events can cause it to move from one state to another.\n\nEvent-driven modeling is used in certain types of systems, such as real-time systems, because these systems often have minimal data processing and need to respond quickly to events. State machine models are used to represent event-driven systems, showing the system's states as nodes and events as arcs between them. When an event happens, the system transitions from one state to another. Refer to notes for diagram"
    },
    {
      "id": 92,
      "module": "MODULE-3",
      "topic": "class diagram, generalization, Aggregation",
      "question": "Draw a simple class diagram for a school system, including classes like \"Student\" and \"Teacher\".",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Based on the provided notes, a simple class diagram for a school system including \"Student\" and \"Teacher\" would show the classes and the associations between them. \n\n**Classes:**\n\n*   **Student:**  This class would represent a student in the school system.\n*   **Teacher:** This class would represent a teacher in the school system.\n\n**Associations:**\n\nThe notes in Module 3, Page 22 mention that an association is a link between classes that indicates a relationship. Using the examples given on that page, the links between Student and Teacher could look like this:\n\n*   A Teacher *teaches* many Students.\n*   A Student *is taught by* one Teacher."
    },
    {
      "id": 93,
      "module": "MODULE-3",
      "topic": "Behavioral Models -Data driven modeling",
      "question": "Explain the behavioral model and its types with real-world examples.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The behavioral model showcases the dynamic behavior of a system, detailing how it responds to events or stimuli. These stimuli can be data arriving for processing or events triggering system actions. It is based on the assumption that a system has a finite number of states and that events (stimuli) may cause a transition from one state to another.\n\nThere are two main types of behavioral models:\n\n1.  Data-Driven Modeling: Primarily used for business systems focused on data processing. These models illustrate the sequence of actions involved in processing input data and generating the associated output. They are useful in requirements analysis to show end-to-end processing within a system. For example, a sequence model processing an order and sending it to a supplier.\n    *   Illustrates actions in processing input data and generating output.\n    *   Useful for requirements analysis to display end-to-end system processing.\n\n2.  Event-Driven Modeling: Commonly applied in real-time systems where minimal data processing occurs. These models display how a system responds to external and internal events, assuming the system has a finite number of states, and events cause transitions between them. State machine models, often represented using statecharts in UML, are used to depict these event-driven behaviors. For example, a landline phone switching system responding to ‘receiver off hook’ event by generating a dial tone.\n    *   Focuses on system responses to external/internal events.\n    *   Suitable for real-time systems.\n    *   Uses state machine models (Statecharts in UML) showing state transitions triggered by events.\n\nState machine models describe the behavior of a system in response to external and internal events. These models illustrate system responses to stimuli and are often used for modeling real-time systems. State machine models represent system states as nodes and events as arcs between these nodes, showing how the system moves from one state to another when an event occurs.\nFor example, refer to the notes for a state model of the Operation state, which would visually represent how the system transitions between different operational states based on specific events or conditions."
    },
    {
      "id": 94,
      "module": "MODULE-3",
      "topic": "sequence diagram Structured methods",
      "question": "Explain the concept and components of a sequence diagram in UML using an online payment system example.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "A sequence diagram in UML models interactions between actors and objects within a system. It visually represents the sequence of these interactions during a specific use case or instance. Key components and their roles in the context of an online payment system are:\n\n1.  **Actors**: Entities external to the system that interact with it. In an online payment system, actors might include the Customer and the Payment Gateway.\n2.  **Objects**: Components within the system that participate in the interactions. Examples include the Shopping Cart, Order Management System, and Bank System.\n3.  **Lifelines**: Vertical dotted lines extending from each actor and object, representing their existence over time during the interaction.\n4.  **Messages**: Arrows between lifelines indicating interactions or method calls. These are annotated to describe the nature of the interaction.\n5.  **Activation Boxes**: Rectangles placed on lifelines to show the period when an object is active, processing a message or performing an action.\n\nConsider an example scenario where a customer makes a payment:\n\n1.  The Customer initiates the payment process via the user interface (UI).\n2.  A message is sent from the Customer to the Shopping Cart to 'Checkout'.\n3.  The Shopping Cart sends a message to the Order Management System to 'Create Order'.\n4.  The Order Management System sends a message to the Payment Gateway to 'Process Payment' with necessary details.\n5.  The Payment Gateway communicates with the Bank System to authorize the transaction.\n6.  The Bank System responds to the Payment Gateway with the transaction status (success or failure).\n7.  The Payment Gateway relays the transaction status back to the Order Management System.\n8.  The Order Management System updates the order status and informs the Shopping Cart.\n9.  The Shopping Cart confirms the payment status to the Customer.\n\nEach of these interactions is represented by annotated arrows on the sequence diagram, showing the order in which the messages are sent and received. Objects and actors are listed along the top, with dotted lines (lifelines) drawn vertically. The interactions between objects are indicated by annotated arrows. This is a behavioral model showing what happens when a system responds to a stimulus from its environment."
    },
    {
      "id": 95,
      "module": "MODULE-4",
      "topic": "Software Design",
      "question": "Explain five different stages in an object-oriented design process.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The object-oriented design process involves several key stages:\n\n1.  **Define the context and modes of use of the system:** This involves understanding the relationships between the software being designed and its external environment. Understanding the context is essential for deciding how to provide the required system functionality and how to structure the system to communicate with its environment.  It also helps in establishing the system's boundaries, which helps decide what features are implemented in the system being designed and what features are in other associated systems.\n2.  **Design the system architecture:** After understanding the interactions, the next step is to design the system architecture by identifying the major components that make up the system and their interactions. This may involve organizing the components using an architectural pattern such as a layered or client-server model.\n3.  **Identify the principal system objects:** This involves identifying object classes based on tangible hardware and data in the system. This process often relies on the skill, experience, and domain knowledge of system designers and is typically iterative.\n4.  **Develop design models:** Design models illustrate the objects and object classes and relationships between these entities.  These models can be static, describing the static structure of the system in terms of object classes and relationships, or dynamic, describing the dynamic interactions between objects.\n5.  **Specify object interfaces:** Object interfaces have to be specified so that the objects and other components can be designed in parallel. Designers should avoid designing the interface representation but should hide this in the object itself. Objects may have several interfaces, which are viewpoints on the methods provided. UML class diagrams (or Java) may be used for interface specification."
    },
    {
      "id": 96,
      "module": "MODULE-3",
      "topic": "Interaction models",
      "question": "Draw the use case diagram of a weather station and explain the use case description.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Based on the provided notes, here's a use case diagram explanation for a weather station:\n\n**Use Case Diagram of a Weather Station:**\nRefer notes for diagram. The use case diagram should depict the interactions between actors and the weather station system. Actors could include:\n\n1.  **Weather Data System:** Receives weather data from the weather station.\n2.  **Station Maintenance System:** Remotely monitors, updates, and fixes weather stations.\n3.  **External Systems (e.g., Weather Forecasting Systems, Climate Change Monitoring Systems):** Receive processed weather data.\n\nUse cases could include:\n\n1.  **Collect Weather Data:** The weather station gathers temperature, pressure, sunshine, rainfall, wind speed, and direction.\n2.  **Process Weather Data:** The weather station performs basic processing of the collected data.\n3.  **Transmit Weather Data:** The weather station sends the processed data to the data management system.\n4.  **Monitor Instruments:** The weather station's software monitors the instruments.\n5.  **Monitor Power:** The software monitors the power supply (battery, solar/wind).\n6.  **Monitor Communication Hardware:** The software monitors the satellite link.\n7.  **Report Faults:** The software reports any faults detected.\n8.  **Manage Power:** The software manages power consumption.\n9.  **Support Reconfiguration:** The software supports remote reconfiguration.\n\n**Use Case Description (Example: Transfer-data use case):**\n\nThe medical receptionist initiates the transaction, and data is transferred to the patient record system. Use case diagrams can be represented diagrammatically and in more detailed textual form in tabular format. Use cases are discrete tasks that involve external interaction with a system. Sequence diagrams can be used to model the interactions between the actors and the objects within a system. A sequence diagram shows the sequence of interactions that take place during a particular use case or use case instance.\n"
    },
    {
      "id": 97,
      "module": "MODULE-4",
      "topic": "Software Design",
      "question": "Define software reuse and explain its levels, including abstraction, object, component, and system.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Software reuse is the process of utilizing existing software components or systems in the development of new software. This approach aims to reduce development time, costs, and improve software reliability.\n\nLevels of software reuse, based on the notes:\n\n1.  **Abstraction Level:** At this level, knowledge of successful abstractions is reused in the design of new software, rather than directly reusing code.\n\n2.  **Object Level:** This involves the direct reuse of objects from a library, eliminating the need to write the code from scratch. Objects are fundamental building blocks in object-oriented programming.\n\n3.  **Component Level:** Components are collections of objects and object classes that can be reused in application systems. These are more complex than individual objects and offer higher-level functionality.\n\n4.  **System Level:** This involves reusing entire application systems, adapting and tailoring them to meet specific requirements. This is the highest level of reuse and can significantly reduce development effort.\n\nSoftware is often built by reusing existing parts to save time and effort."
    },
    {
      "id": 98,
      "module": "MODULE-4",
      "topic": "Software Design",
      "question": "Illustrate how design models are the bridge between the system requirements and the implementation of a system. Draw a sequence diagram describing data collection of weather information systems and a state diagram for the weather station.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Design models act as a crucial bridge in software engineering, connecting abstract system requirements to concrete system implementation. They facilitate communication, understanding, and validation throughout the development lifecycle.\n\n1.  **Definition and Purpose:** Design models are abstract representations of a system, offering different views and perspectives. They aid analysts in understanding system functionality and serve as communication tools with customers (Module 3, Page 2).\n\n2.  **Object-Oriented Design Process:** Design models are used in object-oriented design processes, especially in large systems developed by different teams, acting as vital communication mechanisms.  (Module 4, Page 4).\n\n3.  **Weather Information Systems as Case Study:** The wilderness weather station serves as a case study for illustrating design models.  These models specify how to gather and process data from sensors, emphasizing reliability and maintainability (Module 1, Page 18 & Module 4, Page 5).\n\n4.  **Context and Interaction Models:** Understanding the relationships between the software and its external environment is crucial. Context models display other systems in the environment, while interaction models show how the system interacts with this environment (Module 4, Pages 6-7).\n\n5.  **Sequence Diagram for Data Collection:** A sequence diagram describes the interactions between objects during data collection (Module 4, Page 19 & 22).\n  *   Objects are arranged horizontally.\n  *   Time is represented vertically (top to bottom).\n  *   Interactions are shown as labeled arrows.\n  *   A thin rectangle represents the object being in control.\n\n   Refer to Module 4, Page 22 for sequence diagram describing data collection.\n\n6.  **State Diagram for Weather Station:** State diagrams illustrate how objects respond to service requests and the state transitions triggered by them (Module 4, Page 23).\n\n   Refer to Module 4, Page 24 for the Weather Station state diagram.\n\n7.  **Object Classes and Relationships:** Design models show objects, object classes, and the relationships between them. Static models describe the static structure, while dynamic models describe interactions (Module 4, Page 18).\n\n8.  **Subsystem Models:** Subsystem models show how the design is organized into logical groups of objects, often using packages in UML (Module 4, Page 20).\n\n9.  **Interface Specification:** Object interfaces need to be specified for parallel design of objects and components. UML class diagrams or Java can be used (Module 4, Page 25).\n\n10. **Design Patterns:** Abstract knowledge about problems and solutions can be reused through design patterns, making use of object-oriented characteristics like inheritance and polymorphism (Module 4, Page 27).\n\n11. **Configuration Management:** Configuration management is the process of managing a changing software system, supporting system integration, tracking changes, and compiling/linking components (Module 4, Page 40).\n\n12. **Testing and Validation:** Program testing checks if a program does what it should and discovers defects before release. Testing includes validation testing (ensuring correct performance) and defect testing (exposing defects) (Module 4, Page 49 & 51)."
    },
    {
      "id": 99,
      "module": "MODULE-4",
      "topic": "Software Design",
      "question": "What is a design pattern?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "A design pattern is a way of reusing abstract knowledge about a problem and its solution. It's a description of the problem and the essence of its solution, abstract enough to be reused in different settings. Pattern descriptions often use object-oriented characteristics like inheritance and polymorphism."
    },
    {
      "id": 100,
      "module": "MODULE-4",
      "topic": "Software Design",
      "question": "Explain four essential elements of design pattern.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "PARTIAL",
      "answer": "The four essential elements of a design pattern are:\n\n1.  **Name:** A meaningful identifier for the pattern that allows developers to easily refer to and discuss the pattern.\n2.  **Problem Description:** A description of the problem that the pattern addresses. This helps designers recognize when the pattern is applicable to a specific design challenge. It explains the context in which the pattern can be used.\n3.  **Solution Description:** A template for a design solution that provides an abstract description of how to solve the problem. This is not a concrete design, but a general approach that can be instantiated in different ways depending on the specific context. It describes the elements that make up the design solution, their relationships, and their responsibilities.\n4.  **Consequences:** The results and trade-offs of applying the pattern, including both the benefits and drawbacks. This helps designers understand the implications of using the pattern and make informed decisions about when and where to apply it. Consequences cover aspects like performance, flexibility, and reusability."
    },
    {
      "id": 101,
      "module": "MODULE-4",
      "topic": "Software Design",
      "question": "Describe the Observer pattern with an example.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The Observer pattern separates the display of an object's state from the object itself. \n\nProblem Description:\nIt is used when multiple displays of an object's state are needed. This arises in scenarios where several parts of a system need to react to the same state change.\n\nSolution Description:\nRefer to notes for UML diagram showing the observer pattern in more detail. The core idea involves:\n\n1.  Subject: The object whose state changes.\n2.  Observers: Objects that want to be notified of these changes.\n3.  The subject maintains a list of observers.\n4.  When the subject's state changes, it notifies all observers.\n5.  Each observer then updates its display to reflect the new state.\n\nConsequences:\nWhile effective, it may lead to performance issues because optimizations to enhance display performance are impractical when many displays depend on single data. \n\nExample:\nConsider a weather station system. The 'Weather Data' object holds the current weather conditions (temperature, humidity, pressure). Multiple displays (e.g., a console display, a web interface, a mobile app) need to show this data. Using the Observer pattern:\n\n1.  Weather Data (Subject): Maintains the current weather conditions.\n2.  Console Display, Web Interface, Mobile App (Observers): Display the weather data.\n3.  When the Weather Data changes, it notifies the Console Display, Web Interface, and Mobile App.\n4.  Each observer updates its display to show the new weather information.\n"
    },
    {
      "id": 102,
      "module": "MODULE-4",
      "topic": "Software Design",
      "question": "Explain the various aspects of implementation that are particularly important to software engineering.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Software engineering implementation involves several crucial aspects:\n\n1.  **Reuse:** Modern software development relies heavily on reusing existing components or systems to reduce costs and time. This includes reusing code at the abstraction level (knowledge of successful abstractions), object level (library objects), component level (collections of objects), and system level (entire application systems).\n2.  **Configuration Management:** This involves managing a changing software system. Its aim is to support the system integration process, so all developers can access project code and documents in a controlled way, see changes, and compile and link components to create a system. Activities include version management, system integration, and problem tracking.\n3.  **Integrated Development Environments (IDEs):** IDEs group software development tools to support different aspects of software development within a common framework and user interface, often tailored to specific programming languages like Java.\n4.  **Component/System Deployment Factors:**  These factors include:\n\t*   Ensuring components are deployed on platforms that provide the required hardware and software support.\n\t*   Deploying components on multiple platforms for high availability.\n\t*   Placing components with high communication traffic on the same platform or physically close platforms to reduce delay.\n5.  **Object-Oriented Design Process:** Includes defining the system context and modes of use, designing the system architecture, identifying principal system objects, developing design models, and specifying object interfaces. Design models are essential for communication, especially in large systems.\n6.  **Design Patterns:** Design patterns offer reusable solutions to common problems, using object-oriented characteristics like inheritance and polymorphism. Key elements include a meaningful name, a problem description, a solution description (a template for a design solution), and consequences (results and trade-offs).\n7.  **Interface Specification:** Specifying object interfaces allows for parallel design of objects and other components. Designers should avoid designing the interface representation directly and hide it within the object itself. Objects may have multiple interfaces representing viewpoints on the methods provided, often specified using UML class diagrams or Java.\n8.  **Building or Buying:** The decision to build a system from scratch or buy an off-the-shelf system (COTS) that can be adapted depends on factors like cost and time. The design process then focuses on configuring the features of the chosen system to meet requirements.\n9.  **Host-Target Development:** Software is often developed on a host system and executed on a separate target system."
    },
    {
      "id": 103,
      "module": "MODULE-4",
      "topic": "Software Design",
      "question": "What is host-target development?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Host-target development refers to the practice where production software is not executed on the same computer as the software development environment. Instead, it is developed on one computer, known as the host system, and executed on a separate computer, referred to as the target system. This separation is common in software engineering."
    },
    {
      "id": 104,
      "module": "MODULE-1",
      "topic": "Software engineering",
      "question": "Why is software engineering needed?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Software engineering is needed because it is essential for governments, societies, and global businesses to function properly. Modern infrastructure, utilities, and electronics rely heavily on software systems. Industries like manufacturing, finance, and entertainment are fully software-driven, with over 75% of the global population using software-controlled mobile phones. Additionally, good software engineering methods save money and avoid costly fixes later.\n\nSoftware engineering addresses the increasing complexity of systems and failures to use proper methods, which can lead to project failures. It ensures that software is fast, low-cost, and works well. Furthermore, all software applications need engineering, but not necessarily the same tools or methods."
    },
    {
      "id": 105,
      "module": "MODULE-1",
      "topic": "Integration and configuration",
      "question": "What is configuration management?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Configuration management is the general process of managing a changing software system. The aim of configuration management is to support the system integration process so that all developers can access the project code and documents in a controlled way, find out what changes have been made, and compile and link components to create a system. It involves version management, system integration, and problem tracking."
    },
    {
      "id": 106,
      "module": "MODULE-2",
      "topic": "Software Process activities, Agile software Development and Requirements Analysis (8 hours) Process activities",
      "question": "Explain the four fundamental activities of a software process.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The four fundamental activities of a software process are:\n\n1.  **Software specification:** This involves defining what the software should do and any constraints it must adhere to. This includes gathering requirements, analyzing them, and documenting them thoroughly. Collaboration between stakeholders, users, and engineers is crucial to specify both functional requirements (what the system should do) and non-functional requirements (performance, security, reliability, etc.).\n\n2.  **Software development:** This activity involves converting the software specification into an executable system. This includes system design, which covers the architecture, data structures, and interfaces of the system, as well as implementation (coding) in a programming language. The focus is on transforming ideas and requirements into working software.\n\n3.  **Software validation:** This is the process of ensuring that the software meets user needs and conforms to the specified requirements. This involves activities such as unit testing (testing individual components), integration testing (testing the interaction between components), system testing (testing the entire system), and acceptance testing (testing by users in a real environment). The goal is to detect and fix errors before the software is deployed.\n\n4.  **Software evolution:** Software is rarely truly \"finished\" after its initial release. This activity involves adapting the software to changing requirements, fixing issues that arise, and improving the software's performance over time. This includes corrective maintenance (fixing bugs), adaptive maintenance (adapting to new environments), perfective maintenance (improving performance), and preventive maintenance (preventing future problems). Together, these activities form the software life cycle, ensuring that the product remains useful, reliable, and adaptable throughout its lifespan."
    },
    {
      "id": 107,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "What is development testing?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Development testing is the stage in the software engineering process where an executable software system is developed. It involves activities that are invariably inter-leaved such as software design and implementation. Software design is a creative activity in which you identify software components and their relationships based on a customer's requirements. Implementation is the process of realizing the design as a program.\n\nObjectives of development testing are to detect faults due to interface errors or invalid assumptions about interfaces.\n\nInterface types include:\n\n*   Parameter interfaces: Data passed from one method or procedure to another.\n*   Shared memory interfaces: Block of memory is shared between procedures or functions.\n*   Procedural interfaces: Sub-system encapsulates a set of procedures to be called by other sub-systems.\n*   Message passing interfaces: Sub-systems request services from other sub-systems\n\nInterface errors include:\n\n*   Interface misuse: A calling component calls another component and makes an error in its use of its interface e.g. parameters in the wrong order.\n*   Interface misunderstanding: A calling component embeds assumptions about the behavior of the called component which are incorrect.\n*   Timing errors: The called and the calling component operate at different speeds and out-of-date information is accessed."
    },
    {
      "id": 108,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "How is software testing different from debugging?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Software testing and debugging are distinct but related activities in the software development process. Software testing is a dynamic validation technique intended to demonstrate that a program does what it is intended to do and to discover program defects before it is put into use. It involves executing the program with artificial data and checking the results for errors, anomalies, or information about the program's non-functional attributes.\n\nDebugging, on the other hand, is the process of finding and correcting these errors or defects once they have been identified. Testing can reveal the presence of errors but not their absence. In validation testing, the expectation is that the system performs correctly using a given set of test cases. Defect testing uses test cases designed to expose defects, which can be deliberately obscure and not reflect normal system use."
    },
    {
      "id": 109,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "Differentiate between i. Validation and verification, ii. Black Box testing and White Box testing with an example, iii. Software inspection and Testing, iv. Alpha testing and beta testing.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "{\n \"i. Validation and Verification:\": \"Verification checks if the software is built correctly according to specifications/design. It focuses on process quality and ensures the system meets written requirements during development (before execution). Methods include reviews, walkthroughs, inspections, and static analysis. Example: Verifying if the code enforces the rule that a password must be at least 8 characters, as specified. Validation, on the other hand, checks if the final software meets the customer’s real needs. It focuses on product quality and ensures the system does what the user actually wants after or during development (with execution). Methods include testing, prototyping, and user feedback sessions. Example: Validating whether the login process truly satisfies security needs as desired by the customer wanting a secure login.\",\n \"ii. Black Box testing and White Box testing:\": \"These terms are not explicitly defined in the provided notes. However, based on the descriptions of component testing and system testing we can formulate the following:\nBlack Box Testing (inferred): Black box testing can be associated with System Testing where the integrated components tested for interactions with test policies that define required system test coverage like testing all system functions accessed through menus and combinations of functions, and providing both correct and incorrect user inputs for testing functions. Testers are not concerned with the internal structure but focus on the system's emergent behavior. This corresponds with system testing that checks that components are compatible, interact correctly, and transfer the right data at the right time across their interfaces.\nWhite Box Testing (inferred): White box testing can be associated with Component Testing where each part is tested alone by developers. This relates to structural models and interfaces. \",\n \"iii. Software inspection and Testing:\": \"Software inspection (Verification): As described in notes inspection can be a review of code, or design that checks if the design matches the requirements. It is a static process of checking code without running it. Testing (Validation): Testing involves various levels (unit, integration, system, acceptance). Most time is spent on testing and done dynamically. This is related to validation and makes sure that the software does what the customer actually wants after or during development.\",\n \"iv. Alpha testing and beta testing:\": \"Alpha testing: This testing is inferred and can be related to component and system testing. It can be related to when components are tested individually and after integration by the developers.\nBeta testing: Beta testing is explicitly mentioned and involves real users trying the software and reporting issues, helping developers fix problems before final release. This is also described as customer testing. Real users test the system with real data to find missing or unclear requirements. V-model is also used to show how beta testing occurs post development.\"\n}"
    },
    {
      "id": 110,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "Explain the software testing process.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "The software testing process is a dynamic validation technique intended to demonstrate that a program performs its intended functions correctly and to uncover program defects before the software is released for use. Testing involves executing a program with artificial data and checking the results for errors, anomalies, or information about the program's non-functional attributes.\n\nHere are the stages in the testing process:\n\n1.  **Component Testing**: Individual parts of the software are tested in isolation by developers, often using tools like JUnit.\n2.  **System Testing**: All components are combined and tested to identify interaction issues and ensure that the system meets overall requirements. System testing checks that components are compatible, interact correctly, and transfer the right data at the right time across their interfaces. It tests the emergent behavior of a system. This often involves a separate testing team.\n3.  **Customer Testing**: Real users test the system with real data to uncover missing or unclear requirements.  This includes beta testing, where real users try the software and report issues to help developers fix problems before the final release.\n\nTesting can be categorized as validation testing, where you expect the system to perform correctly using test cases that reflect the system's expected use, and defect testing, where test cases are designed to expose defects, even if they are obscure and do not reflect normal system use.\n\nThe V-model shows how each development stage has a matching test stage, reinforcing that testing is planned from the beginning.\n\nEffective testing requires testing policies that define the required system test coverage. Testing policies may include:\n\n*   Testing all system functions accessed through menus.\n*   Testing combinations of functions accessed through the same menu.\n*   Testing all functions with both correct and incorrect user inputs.\n\nScenario Testing is a Software Testing Technique that uses scenarios i.e. speculative stories to help the tester work through a complicated problem or test system. In scenario testing:\n\n*   Testers assume themselves to be the end users and find the real world scenarios or use cases which can be carried out on the software by the end user.\n*   Testers take help from clients, stakeholders and developers to create test scenarios. A test scenario is a story which describes the usage of the software by an end user."
    },
    {
      "id": 111,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "What is component testing?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Component testing is usually done by programmers during development. The objectives of component testing are to detect faults due to interface errors or invalid assumptions about interfaces. \n\nInterface types include:\n\n*   Parameter interfaces: Data passed from one method or procedure to another.\n*   Shared memory interfaces: Block of memory is shared between procedures or functions.\n*   Procedural interfaces: Sub-system encapsulates a set of procedures to be called by other sub-systems.\n*   Message passing interfaces: Sub-systems request services from other sub-systems.\n\nInterface errors that component testing seeks to uncover include:\n\n*   Interface misuse: A calling component calls another component and makes an error in its use of its interface e.g. parameters in the wrong order.\n*   Interface misunderstanding: A calling component embeds assumptions about the behaviour of the called component which are incorrect.\n*   Timing errors: The called and the calling component operate at different speeds and out-of-date information is accessed."
    },
    {
      "id": 112,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "What is system testing?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "System testing during development involves integrating components to create a version of the system and then testing the integrated system. The focus in system testing is testing the interactions between components, checking that components are compatible, interact correctly, and transfer the right data at the right time across their interfaces. System testing tests the emergent behavior of a system. Reusable components that have been separately developed and off-the-shelf systems may be integrated with newly developed components, and then the complete system is tested. Components developed by different team members or sub-teams may be integrated at this stage. System testing is a collective rather than an individual process, and in some companies, it may involve a separate testing team with no involvement from designers and programmers."
    },
    {
      "id": 113,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "How does component testing differ from other types of testing?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Component testing differs from other types of testing because it is usually done by programmers during development, focusing on individual parts of the software in isolation. In incremental development, each part is tested as it's built. This contrasts with system testing, where all parts are combined and tested for interaction issues and to ensure requirements are met. Additionally, customer testing involves real users testing the system with real data to find missing or unclear requirements. Unlike system testing which is a collective process often involving a separate testing team, component testing is generally conducted by the developers themselves."
    },
    {
      "id": 114,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "Explain requirements-based testing with an example.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Requirements-based testing is a testing approach where test cases are designed and developed based on the requirements specified for the software system. The primary goal is to ensure that all requirements are correctly implemented and that the software functions as expected according to those requirements.\n\nFor example, consider a requirement for an ATM machine: \"The system shall allow the user to withdraw cash successfully\". A test scenario for this requirement could be:\n\nSteps:\n1.  User inserts ATM card. → Expected: Machine asks for PIN.\n2.  User enters correct PIN. → Expected: Access granted.\n3.  User selects \"Withdraw Cash\" option. → Expected: Withdrawal menu appears.\n4.  User enters amount (e.g., ₹500). → Expected: Machine checks balance.\n5.  Balance is sufficient. → Expected: Cash is dispensed, receipt printed, balance updated.\n\nEach step has an expected result, and the test passes if the actual result matches the expected result. This scenario directly tests the specified requirement."
    },
    {
      "id": 115,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "What is scenario testing?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Scenario Testing is a software testing technique that uses scenarios or speculative stories to help the tester work through a complicated problem or test system. The ideal scenario test is a reliable, complicated, convincing, or motivating story the outcome of which is easy to assess. It is performed to ensure that the end-to-end functioning of software and all the process flow of the software are working properly.\n\nIn scenario testing, testers assume they are the end users and find real-world scenarios or use cases that can be carried out on the software. Testers take help from clients, stakeholders, and developers to create test scenarios. A test scenario is a story that describes the usage of the software by an end user.\n\nFor example, using an ATM machine:\nScenario: Withdraw cash successfully.\nSteps:\n1.  User inserts ATM card. Expected: Machine asks for PIN.\n2.  User enters correct PIN. Expected: Access granted.\n3.  User selects \"Withdraw Cash\" option. Expected: Withdrawal menu appears.\n4.  User enters amount (e.g., ₹500). Expected: Machine checks balance.\n5.  Balance is sufficient. Expected: Cash is dispensed, receipt printed, balance updated."
    },
    {
      "id": 117,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "Explain the six stages of the acceptance testing process.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "PARTIAL",
      "answer": "Based on the notes provided, here are the six stages of the acceptance testing process. Note, however, that the notes outline the stages in the *testing process*, not specifically acceptance testing. However, they can be adapted to the context of acceptance testing:\n\n1.  **Component Testing:** Involves testing each individual component or module of the software separately. This is typically performed by developers using tools like JUnit. (Module4.pdf, Page 51)\n\n2.  **System Testing:** All components are integrated and tested as a complete system. This stage focuses on verifying interactions between components and ensuring that the system meets specified requirements. The goal is to uncover integration issues and verify system-level functionality. (Module4.pdf, Page 51, 82, 83).\n\n3.  **Customer Testing:** Real users test the system using real-world data to identify missing requirements or unclear specifications. This phase validates that the system meets user expectations and business needs in a realistic environment. (Module4.pdf, Page 51).\n\n4.  **Requirements Verification:** This step ensures that the initial requirements are clear, complete, and consistent before proceeding with further development and testing phases. (Module3.pdf, Page 67) and (Module4.pdf, Page 44)\n\n5.  **Design Verification:** Check whether design matches requirements.(Module4.pdf, Page 44)\n\n6.  **Code Verification:** Static checks and code reviews. (Module4.pdf, Page 44)"
    },
    {
      "id": 118,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "What is user testing?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Based on the provided notes, user testing is not explicitly defined. However, the notes do mention program testing as a dynamic validation technique where a program is executed using artificial data to check for errors, anomalies, or information about the program's non-functional attributes before it is put into use (Module 4, Page 49). The notes also mention customer testing where real users test the system with real data to find missing or unclear requirements (Module 3, Page 51). Also, in Module 4, Page 97, validation techniques like prototyping are mentioned; it involves developing an executable model of a system and using this with end-users and customers to see if it meets their needs and expectations."
    },
    {
      "id": 119,
      "module": "MODULE-1",
      "topic": "Introduction",
      "question": "Why is software engineering important?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Software engineering is important for two primary reasons:\n\n1.  **Need for Fast, Low-Cost, and Well-Functioning Software:** Software engineering ensures that the developed software meets the essential requirements of being fast, cost-effective, and reliable in its operation. (Page 9)\n\n2.  **Cost Savings and Avoiding Future Fixes:** Applying sound software engineering methods can result in significant cost savings by preventing the need for expensive fixes and rework in later stages of the software lifecycle. (Page 9)\n\nIn addition to this software engineering is essential for the functioning of governments, societies, and global businesses. Modern infrastructure, utilities, and electronics rely heavily on software systems. Industries like manufacturing, finance, and entertainment are fully software-driven. Over 75% of the global population uses software-controlled mobile phones, most internet-enabled. (Page 2)"
    },
    {
      "id": 120,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "What is release testing?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Release testing is performed to demonstrate to the software customer that the system meets its requirements and is ready for use. Release testing is a type of validation testing, ensuring that the software meets the customer’s real needs. (Page 43, MODULE-4)"
    },
    {
      "id": 121,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "How does development testing differ from other forms of testing?",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Development testing is conducted during the software development phase, primarily by the development team. Its main objectives are validation testing, ensuring the software performs correctly, and defect testing, designed to expose defects. Interface testing is a key part of development testing, aiming to detect faults related to interface errors or invalid assumptions about interfaces. These interfaces can be parameter interfaces, shared memory interfaces, procedural interfaces and message passing interfaces.\n\nIn contrast to system testing which involves integrating components to test interactions between components, development testing focuses more on individual units or components. Development testing also differs from customer testing, where real users test the system to find missing requirements."
    },
    {
      "id": 122,
      "module": "MODULE-4",
      "topic": "Software testing",
      "question": "Explain test-driven software development with a diagram and its benefits.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Test-driven development (TDD) is an approach where tests are written before the code itself. The process generally follows these steps:\n\n1.  **Write a Test:** Before writing any code, a test is created that defines a specific function or feature. This test will initially fail because the code doesn't exist yet.\n2.  **Run the Test:** Execute the test to confirm that it fails as expected. This step ensures that the test is correctly set up and will accurately assess the code.\n3.  **Write the Code:** Implement the minimum amount of code necessary to pass the test. The focus is solely on satisfying the test requirements.\n4.  **Run the Test Again:** Execute the test again. If the code works correctly, the test will pass.\n5.  **Refactor:** Improve the code's structure and design without changing its functionality. Refactoring ensures that the code is clean, maintainable, and efficient.\n6.  **Repeat:** Continue the cycle by writing new tests for additional features or functionalities.\n\n**Diagram Description (Refer notes for diagram):**\n\nUnfortunately, there isn't a specific TDD diagram in the notes. However, based on the information provided, a useful diagram would illustrate the cyclical process of TDD, showing the sequence of writing a test, running the test (failure), writing code, running the test (success), refactoring, and then repeating the cycle. Key elements would include arrows indicating the flow between each step and labels describing the activity at each stage.\n\n**Benefits of Test-Driven Development:**\n\n1.  **Early Defect Detection:** Writing tests before code helps identify and fix bugs early in the development cycle, reducing the cost and effort required for debugging later on.\n2.  **Improved Code Quality:** TDD promotes writing clean, well-structured code that is easy to understand and maintain. Refactoring further enhances code quality.\n3.  **Clear Requirements:** Tests serve as executable specifications, providing a clear and precise understanding of what the code should do. This reduces ambiguity and misunderstandings between developers and stakeholders.\n4.  **Reduced Test-Lag:** Helps avoid \"test-lag\", ensuring tests run quickly and often.\n5.  **Better Design:** By focusing on testability, TDD encourages developers to design modular, loosely coupled components that are easier to test and reuse.\n6.  **Increased Confidence:** Passing tests provide confidence that the code is working as expected, reducing the risk of regressions and unexpected behavior.\n7.  **Continuous Integration:** TDD integrates well with continuous integration practices, enabling automated testing and early feedback on code changes.\n8.  **Customer Involvement:** Customer involvement  in creating acceptance tests ensuring the product meets their evolving needs.\n9.  **Catches problems early** resulting in reduced misunderstandings. \n10. **Reduces risks** during refactoring."
    },
    {
      "id": 123,
      "module": "OUT_OF_SYLLABUS",
      "topic": null,
      "question": "What are legacy systems?",
      "marks": 5,
      "syllabus_status": "OUT_OF_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Legacy systems are not explicitly defined in the provided notes. However, based on the context, we can infer that they are existing systems that may need to be integrated with new systems or considered during software development. The notes discuss the importance of understanding existing systems during requirements engineering (Module 3, Page 3; Module 4, Page 3; Module 5, Page 91), assessing existing systems when planning system improvements (Module 3, Page 3; Module 5, Page 53), and integrating with existing systems (Module 4, Page 86). Therefore, legacy systems would be the pre-existing systems that any new system would have to take into account, and likely integrate with."
    },
    {
      "id": 124,
      "module": "MODULE-5",
      "topic": "Software evolution",
      "question": "Explain the components of a legacy system with a neat diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Based on the provided notes, the components of a legacy system are not explicitly defined with a neat diagram. However, the notes discuss software evolution, project management, project planning, and quality management, which are relevant to understanding legacy systems and their maintenance. Since legacy system components are not found but the module number is indicated, I will perform a module based search to answer the question.\n\nThough a specific diagram illustrating the components isn't available, a conceptual understanding can be derived:\n\n1.  **Hardware:** This includes the physical servers, workstations, and network infrastructure on which the legacy system runs. These might be outdated or difficult to maintain.\n\n2.  **Software:** This encompasses the operating system, application code, middleware, and any supporting software required for the system to function. The code may be written in older programming languages.\n\n3.  **Data:** The data stored and processed by the legacy system. This data is often in a proprietary format or stored in a database system that is no longer widely used.\n\n4.  **Interfaces:** The interfaces through which the legacy system interacts with other systems or users. These interfaces may use outdated protocols or data formats.\n\n5.  **Documentation:** Documentation describes the system's functionality, design, and operation. However, documentation for legacy systems may be incomplete or outdated.\n\n6.  **People:** The staff with knowledge of the legacy system, including developers, administrators, and users. Finding and retaining staff with these skills can be challenging.\n\n7.  **Processes:** The business processes that rely on the legacy system. These processes may be inefficient or inflexible due to the limitations of the system.\n\n8.  **Security:** Security mechanisms in place to protect the legacy system and its data. These may be outdated and vulnerable to modern threats.\n\n9.  **Integration Points:** Points where the legacy system connects to other systems, potentially creating dependencies and compatibility issues.\n\n10. **Business Logic:** The rules and algorithms embedded within the system's code that implement specific business functions. Understanding and modifying this logic can be complex."
    },
    {
      "id": 125,
      "module": "MODULE-5",
      "topic": "Software evolution",
      "question": "Explain the layers of a legacy system with a diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "The notes do not explicitly detail the layers of a legacy system. However, based on the content related to system architecture and design, an explanation can be inferred.\n\nA legacy system is an old method, technology, computer system, or application program that is still in use. Legacy systems often have a layered architecture that has evolved over time.\n\nThe diagram should show the following layers:\n\n1.  **Presentation Layer**: This is the user interface layer where users interact with the system. It might be a terminal-based interface or a graphical user interface (GUI).\n2.  **Application Layer**: This layer contains the core business logic and processes of the legacy system. It handles the main functions that the system performs.\n3.  **Data Access Layer**: This layer provides an interface to the database where the system's data is stored. It encapsulates the logic for retrieving, updating, and deleting data.\n4.  **Database Layer**: This is where the system's data is stored, typically in a relational database management system (RDBMS) or a hierarchical database. This layer stores all of the crucial historical information.\n5.  **Infrastructure Layer**: This layer represents the hardware and operating system that the legacy system runs on. It may include servers, networking equipment, and other infrastructure components. The infrastructure layer contains old technology that is difficult to upgrade, such as legacy servers and operating systems.\n\nEach layer communicates with the layer directly above or below it. Communication typically follows a request-response pattern. Legacy systems may lack modern architectural principles, making maintenance and modernization challenging."
    },
    {
      "id": 126,
      "module": "MODULE-5",
      "topic": "Project management",
      "question": "Explain the project planning process with the help of a neat diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Project planning involves creating a detailed roadmap for developing and delivering a software project. It encompasses defining goals, scope, resources, and timelines. Since the context doesn't give a diagram, the textual explanation is provided below:\n\n1.  **Define Project Goals and Objectives:** Clearly state what the project aims to achieve. These goals should be specific, measurable, achievable, relevant, and time-bound (SMART).\n2.  **Scope Definition:** Determine the boundaries of the project. What features will be included, and what will be excluded? This helps prevent scope creep.\n3.  **Work Breakdown Structure (WBS):** Divide the project into smaller, manageable tasks. The WBS makes it easier to estimate time, resources, and costs for each task.\n4.  **Resource Allocation:** Identify the resources needed (e.g., personnel, equipment, software) and assign them to specific tasks. Ensure that resources are available when needed.\n5.  **Task Scheduling:** Create a timeline for completing each task, considering dependencies between tasks. Use project management tools like Gantt charts to visualize the schedule.\n6.  **Cost Estimation:** Estimate the costs associated with each task and the overall project. This includes labor costs, material costs, and other expenses.\n7.  **Risk Management:** Identify potential risks that could impact the project (e.g., technical challenges, resource constraints, changing requirements). Develop mitigation strategies to address these risks.\n8.  **Communication Plan:** Define how project stakeholders will communicate with each other. Establish regular meetings, progress reports, and other communication channels.\n9.  **Quality Management Plan:** Outline the quality standards that the project must meet. Define processes for ensuring that the software meets these standards.\n10. **Change Management Process:** Establish a process for managing changes to project scope, schedule, or budget. This includes documenting change requests, assessing their impact, and obtaining approval before implementation.\n11. **Project Monitoring and Control:** Implement mechanisms for tracking project progress, identifying deviations from the plan, and taking corrective action. Regularly review project status and make adjustments as needed."
    },
    {
      "id": 127,
      "module": "OUT_OF_SYLLABUS",
      "topic": "OUT_OF_SYLLABUS",
      "question": "What is software pricing?",
      "marks": 5,
      "syllabus_status": "OUT_OF_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "I am sorry, but the provided notes do not contain a direct definition or explanation of \"software pricing.\" Therefore, I cannot answer your question using only the given context."
    },
    {
      "id": 128,
      "module": "MODULE-5",
      "topic": "Project management",
      "question": "List and briefly explain the factors affecting software pricing.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Based on the provided notes, I am unable to provide a list of factors affecting software pricing. This specific topic is not covered in the given context. However, the notes do discuss various aspects of software engineering, software processes, requirements engineering, system modeling, software design, implementation, testing, evolution, and project management, but not pricing directly."
    },
    {
      "id": 129,
      "module": "MODULE-5",
      "topic": "Software evolution",
      "question": "What are the risks involved in legacy system replacement?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Based on the notes, the risks involved in legacy system replacement are not explicitly detailed. However, Module 5 generally discusses the evolution of software and project management, implying risks are inherent in software changes and project execution. Although specific risks tied *directly* to legacy system replacement aren't outlined, we can infer potential issues based on related topics:\n\n1.  **Requirement changes:** (Module 4 and 5): Evolving requirements throughout a software lifecycle can pose risks. If a legacy system is being replaced to meet new requirements, these changes must be carefully managed to avoid project disruptions. Unforeseen changes can impact timelines and budgets.\n2.  **Lack of clear understanding**: (Module 3 and 4): A poor grasp of stakeholder needs and the system's context can lead to issues. Legacy system replacement requires a strong understanding of current system functionality and stakeholder needs. This ensures the new system aligns with business goals.\n3.  **Integration complexities**: (Module 4): Integrating new components with existing systems can be challenging. Replacing a legacy system often involves integrating the new system with other active systems. Incompatible interfaces can cause complications.\n4.  **Testing difficulties**: (Module 4): Thorough testing is essential to avoid errors. Replacing a legacy system requires extensive testing, including system and component testing, to detect faults and ensure the new system performs as expected.\n5.  **Data Migration Issues**: Transferring data from the legacy system to the new system can be complicated. Module 3 talks about transforming information which requires proper data translation which can be risky.\n6.  **Lack of configuration management**: (Module 4): Proper configuration management is vital during software evolution. If replacing a legacy system requires significant changes to configurations, managing these changes effectively is key to avoid system instability.\n7.  **Unrealistic expectations**: (Module 5): Setting unrealistic timelines and budgets can lead to project failure. Replacing legacy systems is a complex undertaking that needs careful planning and realistic expectations.\n8.  **Dependability and security:** (Module 4): Non-functional requirements like security and reliability should be considered throughout the whole system. Not doing so would open vulnerabilities.\n9. **Stakeholder Management**: (Module 5 and Module 4): Include key roles like 'ScrumMaster' to guide the team and handle logistics. Neglecting stakeholder needs can create project inefficiencies.\n10. **Lack of proper tools**: (Module 5): Failing to make use of existing debugging tools is a major risk. Use planning, testing and design tools, to get the project done successfully."
    },
    {
      "id": 130,
      "module": "MODULE-5",
      "topic": "Project management",
      "question": "Describe risk identification with the help of a risk item checklist.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Risk identification is not explicitly described using a risk item checklist in the provided notes. However, project management, which inherently involves risk management, is discussed. Therefore, risk identification can be inferred as a component of broader project planning activities. A risk item checklist would serve as a tool within this process.\n\nA risk item checklist aids in:\n\n1.  **Systematic Review:** Providing a structured way to review potential risks, ensuring no common risks are overlooked.\n2.  **Early Detection:** Identifying risks early in the project lifecycle, allowing for timely mitigation strategies.\n3.  **Comprehensive Coverage:** Covering various risk categories, such as technical, operational, and project-related risks.\n4.  **Historical Data:** Drawing upon past project experiences to anticipate potential issues.\n5.  **Stakeholder Communication:** Facilitating discussions among stakeholders to gather diverse perspectives on potential risks.\n6.  **Prioritization:** Helping to prioritize risks based on their potential impact and likelihood.\n7.  **Contingency Planning:** Informing the development of contingency plans to address identified risks.\n8.  **Resource Allocation:** Guiding the allocation of resources to manage and mitigate high-priority risks.\n9.  **Improved Decision-Making:** Enhancing decision-making by considering potential risks and their consequences.\n10. **Continuous Improvement:** Serving as a learning tool for future projects by documenting identified risks and their outcomes."
    },
    {
      "id": 131,
      "module": "MODULE-5",
      "topic": "Project management",
      "question": "Briefly explain the different categories of risks in risk management.",
      "marks": 5,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Risk management involves identifying, assessing, and mitigating potential risks that could impact a project. These risks can be broadly categorized as follows:\n\n1.  **Technical Risks:** These relate to problems with the software or hardware technologies used in the project. Examples include difficulties with system integration, software performance issues, or the failure of a technology to meet the project's needs.\n\n2.  **Organizational Risks:** These risks stem from the project's organizational structure, resources, or management. This might include lack of team experience, poor communication between teams, or changes in organizational priorities.\n\n3.  **External Risks:** These are risks that originate outside of the project team or organization, such as changes in government regulations, economic downturns, or the actions of competitors.\n\n4.  **Schedule Risks:** These risks pertain to the project's timeline, such as unrealistic deadlines, unexpected delays, or inefficient task management.\n\n5.  **Resource Risks:** Concerns the availability of the resources that are required to complete the software project. This can include but is not limited to finances, personnel, infrastructure, software and hardware."
    },
    {
      "id": 132,
      "module": "MODULE-5",
      "topic": "Project management",
      "question": "What is the need for Risk Management, and explain various activities connected to Risk Management?",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "The need for Risk Management is not explicitly stated in the provided notes. However, the various activities connected to Project Management are mentioned, suggesting an implicit need for risk management to ensure project success. Based on the notes, here are activities connected to Project Management:\n\n1.  **Project Planning:** Encompasses activities to define project scope, objectives, and strategies. It is described as a fundamental management activity to reduce the risk of project failure.\n\n2.  **Quality Management:** Includes various aspects such as quality assurance which involves establishing a framework of organizational processes and standards that lead to high-quality software.  Quality control involves ensuring developed software adheres to these standards. Testing plays a crucial role as a dynamic validation technique to detect defects before software deployment. The need for testing stems from potential discrepancies between a program's intended behavior and actual performance.\n\n3.  **Risk Management (Implicit):** While not explicitly detailed, project planning's aim to reduce the risk of project failure implies activities to identify, assess, and mitigate potential issues.\n\n4.  **Configuration Management:** It aims to support the system integration process so that all developers can access the project code and documents in a controlled way, find out what changes have been made, and compile and link components to create a system. Activities include version management, system integration and problem tracking.\n\n5.  **Reuse:** Using existing components or systems. The levels of reuse include the abstraction level, the object level, the component level and the system level.\n\n6.  **Integrated Development Environments (IDEs):** Software development tools are often grouped to create an integrated development environment (IDE). An IDE is a set of software tools that supports diñerent aspects of software development, within some common framework and user interface."
    },
    {
      "id": 133,
      "module": "MODULE-5",
      "topic": "Project management",
      "question": "Explain the product and process standards in software quality management.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Software quality management involves establishing and following standards to ensure the software meets the required quality levels. These standards can be categorized into product standards and process standards.\n\n**Product Standards:**\nProduct standards define characteristics that all components of a software product should exhibit. These ensure consistency and quality across different parts of the software. Examples include:\n\n1.  **Design Reviews:** Structured reviews of the system's design documents, checking for adherence to architectural principles and design best practices. This includes checking interface specifications and data structures.\n2.  **Coding Standards:** Coding standards ensure the code is readable, maintainable, and less prone to errors. Some elements might include:\n    *   Use of meaningful variable names.\n    *   Consistent indentation and formatting.\n    *   Commenting guidelines.\n    *   Restrictions on the use of certain language features.\n3.  **Documentation Standards:** Standards for creating clear, concise, and well-organized documentation. This includes user manuals, API documents, and internal design documents.\n4.  **Testing Standards:** Define how software components and systems should be tested, including test data requirements, test case design, and test execution procedures.\n5.  **Interface Standards:** Standards for how different components of a system should communicate with each other. These standards ensure that components can be easily integrated and interoperate correctly.\n\n**Process Standards:**\nProcess standards define the activities, methods, and practices to be followed during software development. They guide how the software is developed, tested, and maintained to ensure quality. Examples include:\n\n1.  **Requirements Engineering Process:** A structured process for gathering, documenting, and validating requirements, ensuring that the requirements are clear, complete, and consistent.\n2.  **Design Process:** Defines how the software architecture and detailed design are created. This process includes activities like identifying architectural patterns, defining object classes, and specifying interfaces.\n3.  **Testing Process:** Details the stages, methods, and criteria for testing.  This encompasses:\n    *   Component testing.\n    *   System testing, including interface checks and emergent behavior.\n    *   Customer testing for real-world validation.\n    *   Scenario testing to check end-to-end functionality.\n4.  **Configuration Management Process:** This manages changes to software components, keeping track of different versions and supporting system integration by automatically compiling and linking necessary components, along with tracking and resolving bugs.\n5.  **Change Management Process:** A process for handling changes to requirements, ensuring that the changes are properly analyzed, costed, and implemented without disrupting the system."
    },
    {
      "id": 134,
      "module": "MODULE-5",
      "topic": "Software evolution",
      "question": "Explain the software evolution process with a neat diagram.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "CONFIRMED",
      "answer": "Software evolution is the process of adapting software to changing requirements, fixing issues, and improving performance. It acknowledges that software is rarely \"finished\" after its initial release and requires ongoing adaptation. \n\nThe software evolution process can be visualized as a cyclical or iterative process, where modifications are made to existing systems based on continuous assessment and new requirements. Refer notes for diagram (System Development or Improvement Process diagram - Module 5, Page 53) The diagram illustrates a system development or improvement process, emphasizing its iterative nature. The stages are:\n\n1.  **Define System Requirements:** Identify what the system needs to do by gathering information about user needs, business goals, and technical requirements.\n2.  **Assess Existing Systems:** Review the current system to determine what works well and what needs improvement.\n3.  **Propose System Changes:** Suggest improvements or upgrades to address issues or add new features based on the defined requirements.\n4.  **Modify Systems:** Implement the proposed changes, either by updating the existing system or creating a new one.\n5.  **Existing Systems & New System:** Existing systems feed into the assessment stage for evaluation. The new system is created or updated after modifications and may later become the 'existing system' for future improvements.\n\nKey aspects:\n\n*   Software's Flexibility: Software's inherent flexibility makes changes easier and more cost-effective than modifying hardware.\n*   Continuous Process: Development and maintenance are viewed as a single, ongoing process, as systems are updated to meet new needs.\n*   Types of maintenance includes corrective, adaptive, perfective, and preventive maintenance.\n*   The process is continuous, where a new system, once created, undergoes reassessment for further improvements in the future.\n*   The key goal is to ensure the product remains useful, reliable, and adaptable over time."
    },
    {
      "id": 135,
      "module": "MODULE-5",
      "topic": "Software evolution",
      "question": "Explain the four strategic options of legacy system management.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Based on the provided notes, the four strategic options for legacy system management are not explicitly outlined. However, the notes do allude to the concept of software evolution, which is related to managing and adapting existing systems. Though strategic options are not detailed, I will provide an answer using related concepts:\n\n1.  **Encapsulation/Re-engineering**: This involves wrapping the legacy system with new interfaces or re-engineering parts of it to improve specific functionalities. This approach could fall under modifying existing systems to fix issues or add new features based on requirements, as mentioned in Module 3, page 53.\n\n2.  **Replacement**: This option refers to completely replacing the legacy system with a new system. Module 3 Page 53 describes the system development or improvement process mentioning that system changes can include updating the existing system or creating a new one.\n\n3.  **Migration**: Migrating specific functions or data from the legacy system to a newer platform. This leverages a phased approach, minimizing disruption while modernizing parts of the system.\n\n4.  **Phased Modernization**: Incrementally modernizing parts of the system while maintaining core functionality, which aligns with Module 2 regarding incremental delivery where software is delivered in small increments enabling early use and feedback. This could involve integrating new components or web services to augment existing capabilities as described in the Integration and Configuration in Module 1. "
    },
    {
      "id": 136,
      "module": "MODULE-5",
      "topic": "Software evolution",
      "question": "Draw a chart showing the relative business value and system quality of legacy system management, and explain four clusters of systems.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Based on the provided notes, a chart illustrating the relative business value and system quality of legacy system management isn't available. However, the notes do discuss software evolution and project management which are related concepts. Here's an explanation of system clusters as per the available notes:\n\nFour clusters of systems (though not explicitly termed 'clusters' in the sense of business value vs. system quality) can be inferred from the different application types discussed throughout the notes:\n\n1.  **Stand-alone Applications:** (module1.pdf, page 12) These are generic products sold on the open market, such as Microsoft Office. Business value: widely applicable. System quality: aims for broad compatibility and usability.\n\n2.  **Interactive Transaction-Based Applications:** (module1.pdf, page 13) Examples include e-commerce web applications. Business value: direct revenue generation. System quality: emphasizes security, reliability, and performance.\n\n3.  **Embedded Control Systems:** (module1.pdf, page 13) Software controlling devices like mobile phones or car antilock braking systems. Business value: integral to device functionality. System quality: focuses on real-time performance, reliability, and safety.\n\n4.  **Systems of Systems:** (module1.pdf, page 14) Such as ERP (Enterprise Resource Planning) software. Business Value: High, it integrates various business processes. System Quality: Focus on integration, scalability and reliability.\n\nThese clusters are based on the characteristics and examples provided in the notes and the context in which they are typically used, suggesting a basic mapping between their function and inherent value and quality requirements. However, a relative chart of business value vs system quality is not mentioned, so I cannot fulfil that part of your request. The notes also mention other types of systems like batch processing systems, entertainment systems, systems for modeling and simulation, and data collection and analysis systems each with varying degrees of business value and required system quality characteristics."
    },
    {
      "id": 137,
      "module": "MODULE-5",
      "topic": "Project management",
      "question": "Explain the factors considered to assess the technical quality of an application system for legacy system management.",
      "marks": 8,
      "syllabus_status": "IN_SYLLABUS",
      "repeat_count": 1,
      "sources": [
        "SEP_22CSE51_QUESTION_BANK.docx.pdf"
      ],
      "importance": "LOW",
      "notes_validation": "NOT_FOUND",
      "answer": "Based on the provided notes, assessing the technical quality of an application system for legacy system management involves several factors, which can be broadly categorized but are not detailed in the context.\n\nWhile the provided notes do not explicitly detail the factors considered to assess the technical quality of an application system for legacy system management, the notes do touch on several aspects relevant to software quality and management that could be adapted and considered in such an assessment. Here's a breakdown of factors that can be inferred from different modules and how they might apply:\n\n1.  **Maintainability and Reliability:**\n*   Sensor-based data collection systems emphasize reliability and ease of maintenance, which is critical for legacy systems to ensure continuous operation.\n\n2.  **System Architecture and Integration:**\n*   Architectural design is crucial for identifying major components and their interactions, impacting how well the legacy system integrates with newer systems.\n*   Integration and configuration involve reusing existing code, which is vital for managing legacy systems cost-effectively.\n\n3.  **Non-Functional Requirements:**\n*   The notes classify non-functional requirements (NFRs) into product, organizational, and external categories.\n*   **Product Requirements:** Performance, reliability, security, and usability are crucial for assessing the technical quality.\n*   **Organizational Requirements:** Compatibility with existing environments and adherence to development standards are also important.\n*   **External Requirements:** Compliance with regulatory and ethical standards ensures the system meets external obligations.\n\n4.  **Testing and Validation:**\n*   Software validation ensures the system meets user needs and conforms to requirements, including unit, integration, system, and acceptance testing.\n*   The V-model illustrates how each development stage has a matching test stage, reinforcing the importance of early testing.\n\n5.  **Code Quality and Refactoring:**\n*   Refactoring is emphasized for keeping code clean, simple, and easier to change, which is essential for maintaining legacy systems.\n\n6.  **Requirements Management:**\n*   Tracking and linking requirements to assess change impact are critical for managing legacy systems' evolution.\n*   A formal change management process ensures changes are properly analyzed and implemented without disrupting the system.\n\n7.  **Agile Principles and Adaptability:**\n*   Agile methodologies emphasize adaptability and continuous improvement, which can be applied to managing and modernizing legacy systems.\n\n8. **Evolution and Continuous Improvement:** The system development or improvement process emphasizes assessing existing systems and proposing changes. This continuous cycle is crucial for legacy systems.\n\n9. **Reusability:** Given the need for cost-effectiveness, the extent to which the legacy system can reuse existing components should be evaluated.\n\n10. **Configuration Management:** The CM principles are key. Assessing how well the legacy system supports version management, system integration, and problem tracking would contribute to understanding the technical quality."
    }
  ]
}